{"version":3,"file":"/dist/js/formfield.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,6DAA6D;AAC3I;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,WAAW,GAAG,iBAAiB;AACpD,sBAAsB,WAAW,GAAG,kBAAkB;;AAEtD;AACA;AACA;AACA;AACA,iDAAiD,IAAI,IAAI,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS,IAAI,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,uBAAuB,aAAa,uBAAuB;AACtI;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB,IAAI,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,GAAG,gBAAgB,KAAK,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI,GAAG,kCAAkC;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B,cAAc;AACxC;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,oEAAoE;AACpE;AACA,OAAO;AACP,6BAA6B,YAAY,GAAG,+BAA+B;AAC3E;AACA,cAAc,QAAQ;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA,4CAA4C;AAC5C;AACA,gDAAgD;AAChD;AACA,WAAW;AACX,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC;AACvD;AACA,6BAA6B,aAAa,GAAG,qBAAqB;AAClE;AACA;AACA;AACA,OAAO;AACP,cAAc,QAAQ;AACtB,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,GAAG,kBAAkB;AACvD,uBAAuB,YAAY,GAAG,mBAAmB;AACzD,sBAAsB,YAAY,GAAG,kBAAkB;AACvD,qBAAqB,YAAY,GAAG,iBAAiB;;AAErD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B,cAAc;AACxC;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,oEAAoE;AACpE;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC;AACvD;AACA,6BAA6B,cAAc,GAAG,yCAAyC;AACvF;AACA;AACA;AACA,OAAO;AACP,cAAc,QAAQ;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,sDAAsD;AACtD,6BAA6B,aAAa,GAAG,6BAA6B;AAC1E;AACA,cAAc,QAAQ;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,cAAc,QAAQ;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,YAAY,GAAG,kBAAkB;;AAEvD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B,cAAc;AACxC;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,oEAAoE;AACpE;AACA,OAAO;AACP,6BAA6B,aAAa,GAAG,+BAA+B;AAC5E;AACA,cAAc,QAAQ;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY;AAC9B,uBAAuB,YAAY;;AAEnC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B,cAAc;AACxC;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,sDAAsD;AACtD;AACA,6BAA6B,QAAQ,GAAG,+BAA+B;AACvE;AACA,cAAc,QAAQ;AACtB,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,sDAAsD;AACtD;AACA;AACA,6BAA6B,QAAQ,GAAG,+BAA+B;AACvE;AACA,cAAc,QAAQ;AACtB,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B;;AAE5B;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,aAAa;AACvB,0BAA0B;AAC1B;AAmBE;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACp0BA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,6DAA6D;AAC3I;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,wBAAwB;AAChE,mEAAmE,IAAI,KAAK;AAC5E;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY,EAAE,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS,EAAE,8CAA8C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACsD;;AAEtD;AACA;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,GAAG,QAAQ;AACjE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI;AACzF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B,IAAI,UAAU;AACxD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mEAAmE,QAAQ;AAC3E,iEAAiE,QAAQ;AACzE;AACA,+DAA+D,kBAAkB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,oDAAoD,iDAAiD;AACrG;AACA;AACA;AACA;AACA,4BAA4B,IAAI,IAAI,OAAO;AAC3C;AACA;AACA;AACA;AACA,oEAAoE,KAAK,EAAE,SAAS;AACpF;AACA;AACA,kBAAkB,sBAAsB,EAAE,gBAAgB,IAAI,IAAI,IAAI,aAAa,eAAe;AAClG,0BAA0B,IAAI,IAAI,cAAc;AAChD;AACA,sBAAsB,gBAAgB,EAAE,gBAAgB;AACxD;AACA,qCAAqC;AACrC,gDAAgD,yCAAyC;AACzF;AACA;AACA;AACA,uCAAuC;AACvC,iDAAiD,2CAA2C;AAC5F;AACA;AACA;;AAEA;AAM0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,+BAA+B,sDAAI;AACnC;AACA;AACA,cAAc,OAAO,QAAQ,iEAAe;AAC5C;AACA,iBAAiB,EAAE;AACnB,gBAAgB,EAAE;AAClB,OAAO;AACP,KAAK;AACL;AACA;AACA,iEAAiE;AACjE,mBAAmB,4DAAU;AAC7B;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,gCAAgC,cAAc,eAAe,cAAc,UAAU,aAAa,SAAS,wCAAwC,qBAAqB,kCAAkC,4BAA4B,uBAAuB,8BAA8B,sBAAsB,8BAA8B,8BAA8B,0BAA0B,gBAAgB,kBAAkB,wBAAwB,sCAAsC,mBAAmB,aAAa,iCAAiC,mBAAmB,2BAA2B,+DAA+D,kBAAkB,YAAY,mBAAmB,aAAa,uBAAuB,kBAAkB,eAAe,gCAAgC,6CAA6C,mBAAmB,8CAA8C,gBAAgB,kCAAkC,gBAAgB,iBAAiB,kCAAkC,aAAa,oBAAoB,kCAAkC,sBAAsB,4BAA4B,kCAAkC,qBAAqB,aAAa,gBAAgB,SAAS,UAAU,OAAO,aAAa,WAAW,wCAAwC,qBAAqB,kCAAkC,4BAA4B,uBAAuB,8BAA8B,sBAAsB,8BAA8B,8BAA8B,uBAAuB,iBAAiB,cAAc,kBAAkB,WAAW,YAAY,aAAa,UAAU,wBAAwB,SAAS,YAAY,cAAc,kBAAkB,MAAM,WAAW,YAAY,WAAW,mBAAmB,gBAAgB,YAAY,cAAc,eAAe,aAAa,YAAY,gBAAgB,UAAU,WAAW,yBAAyB,0BAA0B,UAAU,aAAa,gBAAgB,cAAc,aAAa,iEAAiE,oEAAoE,4DAA4D,aAAa,YAAY,0BAA0B,GAAG,4BAA4B,oBAAoB,GAAG,gCAAgC,yBAAyB,kBAAkB,GAAG,4BAA4B,oBAAoB,GAAG,gCAAgC,yBAAyB,OAAO,6BAA6B,SAAS,cAAc,sBAAsB,aAAa,YAAY,SAAS,gBAAgB,eAAe,uBAAuB,mBAAmB,WAAW,kBAAkB,aAAa,aAAa,mBAAmB,kCAAkC,gBAAgB,cAAc,sBAAsB,UAAU,+GAA+G,aAAa,2BAA2B,mBAAmB,sCAAsC,SAAS,aAAa,uBAAuB,OAAO,eAAe,QAAQ,MAAM,wBAAwB,aAAa,mDAAmD,uDAAuD,mBAAmB,6CAA6C,kBAAkB,kCAAkC,sBAAsB,OAAO,wCAAwC,qBAAqB,kCAAkC,4BAA4B,uBAAuB,8BAA8B,sBAAsB,8BAA8B,8BAA8B,4BAA4B,WAAW,oCAAoC,2BAA2B,qBAAqB,kCAAkC,WAAW,OAAO,4BAA4B,8BAA8B,aAAa,mBAAmB,0BAA0B,aAAa,4BAA4B,kCAAkC,6BAA6B,iBAAiB,WAAW,UAAU,kCAAkC,yCAAyC,yCAAyC,4BAA4B,aAAa,MAAM,yBAAyB,wBAAwB,gBAAgB,4BAA4B,kBAAkB,OAAO,kBAAkB,aAAa,4BAA4B,0BAA0B,kBAAkB,+BAA+B,aAAa,gBAAgB,kCAAkC,iBAAiB,kBAAkB,0BAA0B,8BAA8B,6BAA6B,kCAAkC,0BAA0B,QAAQ,kCAAkC,eAAe,sCAAsC,0BAA0B,uBAAuB,kBAAkB,iBAAiB,WAAW,0BAA0B,aAAa,sBAAsB,qCAAqC,6BAA6B,wBAAwB,uCAAuC,4BAA4B,kBAAkB,GAAG,UAAU,GAAG,WAAW,sBAAsB,8BAA8B,sBAAsB,8BAA8B,8BAA8B,wCAAwC,aAAa,uBAAuB,kCAAkC,gBAAgB,cAAc,aAAa,iBAAiB,gBAAgB,kBAAkB,YAAY,mBAAmB,qBAAqB,sBAAsB,eAAe,OAAO,gBAAgB,kBAAkB,MAAM,cAAc,eAAe,SAAS,kBAAkB,QAAQ,mBAAmB,0BAA0B,wBAAwB,wBAAwB,SAAS,OAAO,mBAAmB,kBAAkB,0BAA0B,eAAe,cAAc,YAAY,WAAW,wBAAwB,qCAAqC,SAAS,yDAAyD,cAAc,kBAAkB,QAAQ,0BAA0B,sBAAsB,qBAAqB,gCAAgC,cAAc,0BAA0B,4CAA4C,gBAAgB,oBAAoB,sBAAsB,4BAA4B,wBAAwB,sBAAsB,kBAAkB,4BAA4B,eAAe,WAAW,kBAAkB,qBAAqB,mBAAmB,UAAU,eAAe,4BAA4B,8BAA8B,sBAAsB,0BAA0B,iCAAiC,aAAa,oBAAoB,YAAY,aAAa,8BAA8B,kBAAkB,qBAAqB,4BAA4B,4BAA4B,qBAAqB,wCAAwC,2BAA2B,WAAW,YAAY,YAAY,kBAAkB,gBAAgB;;AAEz/N;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kFAAkF,iBAAiB,EAAE,qDAAqD,aAAa,QAAQ,IAAI,cAAc,KAAK,iBAAiB;AACvN,yDAAyD,iBAAiB,EAAE,qDAAqD;;AAEjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B,YAAY,oBAAoB,mBAAmB,iBAAiB,aAAa,mBAAmB,oBAAoB,WAAW;AACjN;AACA,oCAAoC,KAAK,IAAI,oBAAoB;AACjE;AACA;AACA;AACA;AACA;AACA,gEAAgE,KAAK,IAAI,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,aAAa,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,0CAA0C;AAC1C;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA,iDAAiD,GAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wBAAwB;AAClC;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAGgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2EAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AAGgC;;AAEhC;AAIgC;AACC;AACY;;AAE7C;AACuE;AACvE;AACA;AACA;AACA,oCAAoC,gEAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,wDAAwD;AACpE;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAwD;AACpE;AACA;AACA,IAAI,oDAAY;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,cAAc,0FAA0F;AACxG,cAAc,8CAA8C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mDAAW;AACjB;AACA,qCAAqC,2DAAe;AACpD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,cAAc,4BAA4B;AAC1C,2BAA2B,kEAAc;AACzC;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,8FAA8F,uEAAmB;AACjH,gBAAgB,uCAAuC;AACvD;AACA,mBAAmB;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA,6BAA6B,2EAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wCAAwC,EAAE,oCAAoC;AACvF;AACA;AACA;AACA,gEAAgE,IAAI;AACpE;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,GAAG,yBAAyB,wBAAwB,YAAY;AAC1F,UAAU,+CAA+C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ,GAAG,oBAAoB;AACvE;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC;AACvD;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sCAAsC;AACpD;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,iEAAiE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sCAAsC;AACpD;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAIgC;;AAEhC;AACkD;;AAElD;AACA,gHAAgH,sCAAsC,2FAA2F,uCAAuC,kCAAkC,GAAG,wCAAwC,GAAG,yCAAyC,mCAAmC,GAAG,yCAAyC,GAAG,0CAA0C;;AAE7gB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA,wBAAwB,gEAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uEAAmB;AACzD,qCAAqC,iEAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAMgC;AACJ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAa,GAAG;AACpD,sCAAsC,iEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2EAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAY;AAChD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kCAAkC;AAClC,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACgD;;AAEhD;AAC0D;AAC1D,eAAe,kEAAiB,GAAG,+BAA+B;AAClE;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,+DAA+D;AAC7E;AACA;AACA,oEAAoE,WAAW,mBAAmB,WAAW;AAC7G,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB;AAC5E,6EAA6E,UAAU;AACvF,iEAAiE,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAyD;AACvE;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA,QAAQ;AACR,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAM;AACnC;AACA,0BAA0B,SAAS;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,KAAK;AACL;AACA,qBAAqB,8FAA8F;AACnH,KAAK;AACL;AACA,cAAc,qEAAqE;AACnF,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA,0DAA0D,2BAA2B;AACrF,2DAA2D,4BAA4B;AACvF,oDAAoD,4BAA4B;AAChF,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,OAAO;AACP,cAAc,yCAAyC;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc,sDAAsD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0DAA0D;AACjH,KAAK;AACL;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,sDAAsD,wDAAwD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAqD;AACjE;AACA;AACA;AACA;AACA,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAA6E;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAKgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C,oCAAoC;AACnF;AACA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,oCAAoC;AACnF;AACA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sCAAsC,iEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2DAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,uCAAuC,uEAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,yDAAyD;AACzD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYE;AACF;;;;;;;;;;;ACljHA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,aAAa,QAAQ;AACrB,kBAAkB,SAAS;AAC3B,YAAY,QAAQ;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,kBAAkB,SAAS;AAC3B,YAAY,QAAQ;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,WAAW,QAAQ;AACnB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED,IAAI,IAA+D;AACnE;AACA;;;;;;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACwE;;AAExE;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG,mDAAmD;AACtD;;;AAGA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,MAAM;AACjB,aAAa,GAAG;AAChB;;;AAGA;AACA,2FAA2F,aAAa;AACxG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,QAAQ;AACrB,aAAa,kBAAkB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,QAAQ;AACvB,8EAA8E;AAC9E;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,8CAA8C;AAC7D,kDAAkD;AAClD,uDAAuD;AACvD;AACA,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;;AAEA;AACA,mGAAmG,eAAe;AAClH;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;;AAEA,4BAA4B;;AAE5B;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,4FAA4F;;AAE5F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,kDAAQ,qCAAqC,kEAAkE;AACzI;;AAEA,2BAA2B,mDAAS;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC,mBAAmB,SAAS,8CAA8C;AAC1E;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,oDAAU;AAC/B,aAAa;AACb;;AAEA;AACA,mBAAmB,oDAAU;AAC7B,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,GAAG;;AAER;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,wDAAwD,qDAAW;AACnE,OAAO;AACP;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA,MAAM;;;AAGN;AACA,KAAK;;;AAGL;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,6EAA6E,qDAAW,qCAAqC,oDAAU;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,4EAA4E,qDAAW,qCAAqC,oDAAU;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA,MAAM;;;AAGN,yCAAyC;AACzC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAE2B;AAC3B;;;;;;;;;;;ACxvBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oDAAoD,YAAY,uBAAuB,YAAY,gBAAgB;AACnH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM,KAA6B;AACnC;AACA,IAAI;AACJ;AACA;AACA,CAAC;;;;;;;;;;;AClED;AACA,MAAM,KAA4B;AAClC;AACA,CAAC;AACD;AACA;AACA,4BAA4B,IAAI,mBAAmB,EAAE,gCAAgC,EAAE,gCAAgC,EAAE,OAAO,EAAE;AAClI;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB,qBAAqB,EAAE;AACvB,qBAAqB,EAAE;AACvB,qBAAqB,EAAE,SAAS,EAAE;AAClC;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;ACjDD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,4BAA4B;AACvC,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,oBAAoB;AACjC;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,WAAW;AACzB;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,uBAAuB,iDAAiD;AACtF;AACA;AACA,cAAc,4BAA4B;AAC1C,cAAc,SAAS;AACvB,cAAc,kBAAkB;AAChC;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB,WAAW,kBAAkB;AAC7B,aAAa;AACb;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI,oEAAoE;AACxE,+BAA+B;AAC/B;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,6BAA6B;AAC7B,0DAA0D;AAC1D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEwD;AACxD;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5eA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB;AACvB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,4CAA4C;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,2HAA2H;;AAEnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,OAAO,GAAG;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wBAAwB;AAC5B;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,yEAAyE;AACzE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE;AACzE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;;AAErF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA,OAAO;AACP,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAuB,yBAAyB,KAAK;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEwI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnmC7C;AACmC;;AAE9H;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6EAA6E;;AAE7E;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mEAAgB;AAC3B;;AAEA;AACA;AACA;;AAEA,SAAS,mEAAgB;AACzB,EAAE;AACF;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,kEAAiB;AAC3E;AACA;AACA,CAAC;;AAE4D;;;;;;;UCvlB7D;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNsD;AAEtDC,QAAQ,CAACC,kBAAkB,GAAG,YAAM;EAChC,IAAID,QAAQ,CAACE,UAAU,KAAK,aAAa,EAAE;IAEvC,IAAMC,SAAS,GAAGH,QAAQ,CAACI,cAAc,CAAC,SAAS,CAAC;IACpD,IAAMC,YAAY,GAAGL,QAAQ,CAACI,cAAc,CAAC,SAAS,CAAC;IACvD,IAAME,SAAS,GAAGN,QAAQ,CAACI,cAAc,CAAC,MAAM,CAAC;IACjD,IAAMG,QAAQ,GAAGP,QAAQ,CAACI,cAAc,CAAC,UAAU,CAAC;IACpD,IAAMI,QAAQ,GAAGR,QAAQ,CAACI,cAAc,CAAC,WAAW,CAAC;IAErD,IAAMK,MAAM,GAAGT,QAAQ,CAACU,gBAAgB,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC;IACtE,IAAIV,QAAQ,CAACW,SAAS,EAAE;MACpBF,MAAM,CAACG,OAAO,GAAGZ,QAAQ,CAACW,SAAS;IACvC;IAEAF,MAAM,CAACG,OAAO,CAEdH,MAAM,CAACI,gBAAgB,CAAC,UAAU,EAAE,UAACC,KAAK,EAAK;MAC3C,IAAIC,UAAU,GAAGD,KAAK,CAACE,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,CAACF,UAAU;MACpD,IAAIG,QAAQ,GAAGJ,KAAK,CAACE,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,CAACC,QAAQ;MAChDC,OAAO,CAACC,GAAG,CAACF,QAAQ,CAAC;MACrBf,SAAS,CAACkB,KAAK,GAAGN,UAAU,CAACO,YAAY;MACzCjB,YAAY,CAACgB,KAAK,GAAGN,UAAU,CAACQ,OAAO;MACvCjB,SAAS,CAACe,KAAK,GAAGN,UAAU,CAACS,UAAU;MACvCjB,QAAQ,CAACc,KAAK,GAAGH,QAAQ,CAACO,WAAW,CAAC,CAAC,CAAC;MACxCjB,QAAQ,CAACa,KAAK,GAAGH,QAAQ,CAACO,WAAW,CAAC,CAAC,CAAC;IAC5C,CAAC,CAAC;EACN;AACJ,CAAC,C","sources":["webpack:///./node_modules/@mapbox/search-js-core/dist/index-esm.js","webpack:///./node_modules/@mapbox/search-js-web/dist/index-esm.js","webpack:///./node_modules/@mapbox/sphericalmercator/sphericalmercator.js","webpack:///./node_modules/focus-trap/dist/focus-trap.esm.js","webpack:///./node_modules/no-scroll/index.js","webpack:///./node_modules/subtag/subtag.js","webpack:///./node_modules/tabbable/dist/index.esm.js","webpack:///./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs","webpack:///./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./client/js/formfield.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/autofill/constants.ts\nvar SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_SUGGEST = \"suggest\";\nvar ENDPOINT_RETRIEVE = \"retrieve\";\nvar SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nvar RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n\n// src/LngLat.ts\nvar LngLat = class {\n  constructor(lng, lat) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\"Invalid LngLat longitude value: must be between -180 and 180\");\n    }\n  }\n  toArray() {\n    return [this.lng, this.lat];\n  }\n  toString() {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n  static convert(input) {\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n    if (!Array.isArray(input) && typeof input == \"object\" && input !== null && (\"lng\" in input || \"lon\" in input) && \"lat\" in input) {\n      return new LngLat(Number(\"lng\" in input ? input.lng : input.lon), Number(input.lat));\n    }\n    throw new Error(\"`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n  }\n};\n\n// src/LngLatBounds.ts\nvar LngLatBounds = class {\n  constructor(sw, ne) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n  getSouthWest() {\n    return this._sw;\n  }\n  getNorthEast() {\n    return this._ne;\n  }\n  getNorthWest() {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n  getSouthEast() {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n  getWest() {\n    return this._sw.lng;\n  }\n  getSouth() {\n    return this._sw.lat;\n  }\n  getEast() {\n    return this._ne.lng;\n  }\n  getNorth() {\n    return this._ne.lat;\n  }\n  toArray() {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n  toFlatArray() {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n  toString() {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n  static convert(input) {\n    if (!input) {\n      throw new Error(\"Invalid LngLatBounds convert value: falsy\");\n    }\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));\n    }\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(LngLat.convert([input[0], input[1]]), LngLat.convert([input[2], input[3]]));\n    }\n    throw new Error(\"`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]\");\n  }\n};\n\n// src/utils/uuid.ts\nfunction generateUUID() {\n  const randomString = Math.random().toString(16) + Date.now().toString(16) + Math.random().toString(16);\n  const uuidString = randomString.replace(/\\./g, \"\");\n  const uuid = [\n    uuidString.slice(0, 8),\n    uuidString.slice(8, 12),\n    \"4\" + uuidString.slice(12, 15) + \"-8\" + uuidString.slice(15, 18),\n    uuidString.slice(18, 30)\n  ].join(\"-\");\n  return uuid;\n}\n\n// src/SessionToken.ts\nvar SessionToken = class {\n  constructor(id) {\n    this.id = id != null ? id : generateUUID();\n  }\n  toString() {\n    return this.id;\n  }\n  static convert(token) {\n    return new SessionToken(token instanceof SessionToken ? token.id : token.toString());\n  }\n};\n\n// src/MapboxError.ts\nvar UNKNOWN_ERROR = \"Unknown error\";\nvar MapboxError = class extends Error {\n  constructor(json, statusCode) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = \"MapboxError\";\n    this.statusCode = statusCode;\n  }\n  toString() {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n};\nfunction handleNonOkRes(res) {\n  return __async(this, null, function* () {\n    if (!res.ok) {\n      const json = yield res.json();\n      throw new MapboxError(json, res.status);\n    }\n  });\n}\n\n// src/fetch.ts\nvar _fetchImpl = globalThis.fetch;\nvar _abortControllerImpl = globalThis.AbortController;\nfunction polyfillFetch({ fetch, AbortController }, force = false) {\n  if (!fetch) {\n    throw new Error(\"Fetch implementation must include implementations of `fetch`.\");\n  }\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\nfunction getFetch() {\n  if (!_fetchImpl) {\n    throw new Error(\"Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.\");\n  }\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n\n// src/utils/queryParams.ts\nfunction queryParams(...objects) {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj)\n      continue;\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null)\n        continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n  return params.join(\"&\");\n}\n\n// src/autofill/AddressAutofillCore.ts\nvar _getQueryParams, getQueryParams_fn;\nvar _AddressAutofillCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _AddressAutofillCore.defaults), defaults);\n  }\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n      const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return __spreadProps(__spreadValues({}, json), {\n        suggestions: json.suggestions.map((suggestion) => {\n          return __spreadProps(__spreadValues({}, suggestion), {\n            original_search_text: searchText\n          });\n        }),\n        url: url.toString()\n      });\n    });\n  }\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n      if (!this.canRetrieve(suggestion)) {\n        throw new Error(\"suggestion cannot be retrieved\");\n      }\n      const { sessionToken: sessionTokenLike, signal } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(`${RETRIEVE_URL}/${suggestion.action.id}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), { signal });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  canRetrieve(suggestion) {\n    const action = suggestion.action;\n    return typeof (action == null ? void 0 : action.id) === \"string\";\n  }\n};\nvar AddressAutofillCore = _AddressAutofillCore;\n_getQueryParams = new WeakSet();\ngetQueryParams_fn = function(options) {\n  return queryParams({\n    types: \"address\",\n    streets: true,\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\nAddressAutofillCore.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n};\n\n// src/searchbox/constants.ts\nvar SEARCH_URL2 = `https://api.mapbox.com/search/searchbox/v1`;\nvar ENDPOINT_SUGGEST2 = \"suggest\";\nvar ENDPOINT_RETRIEVE2 = \"retrieve\";\nvar ENDPOINT_CATEGORY = \"category\";\nvar ENDPOINT_REVERSE = \"reverse\";\nvar SUGGEST_URL2 = `${SEARCH_URL2}/${ENDPOINT_SUGGEST2}`;\nvar RETRIEVE_URL2 = `${SEARCH_URL2}/${ENDPOINT_RETRIEVE2}`;\nvar CATEGORY_URL = `${SEARCH_URL2}/${ENDPOINT_CATEGORY}`;\nvar REVERSE_URL = `${SEARCH_URL2}/${ENDPOINT_REVERSE}`;\n\n// src/searchbox/SearchBoxCore.ts\nvar _getQueryParams2, getQueryParams_fn2;\nvar _SearchBoxCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams2);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _SearchBoxCore.defaults), defaults);\n  }\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        q: searchText,\n        sessionToken\n      });\n      if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n        throw new Error(\"to provide eta estimate: eta, navigation_profile, and origin are required\");\n      }\n      if (options.origin && !options.navigation_profile) {\n        throw new Error(\"to provide distance estimate: both navigation_profile and origin are required\");\n      }\n      const url = new URL(SUGGEST_URL2);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n      const { sessionToken: sessionTokenLike, signal } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(`${RETRIEVE_URL2}/${encodeURIComponent(suggestion.mapbox_id)}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  category(_0) {\n    return __async(this, arguments, function* (category, optionsArg = {}) {\n      if (!category) {\n        throw new Error(\"category is required\");\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const url = new URL(`${CATEGORY_URL}/${encodeURIComponent(category)}`);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  reverse(_0) {\n    return __async(this, arguments, function* (lngLat, optionsArg = {}) {\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n      const [lng, lat] = typeof lngLat === \"string\" ? lngLat.split(\",\").map((x) => parseFloat(x)) : LngLat.convert(lngLat).toArray();\n      if (isNaN(lng) || isNaN(lat)) {\n        throw new Error(\"lngLat is required\");\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const url = new URL(REVERSE_URL);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit,\n        longitude: lng,\n        latitude: lat\n      }, options.types && {\n        types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n};\nvar SearchBoxCore = _SearchBoxCore;\n_getQueryParams2 = new WeakSet();\ngetQueryParams_fn2 = function(options) {\n  return queryParams({\n    q: options.q,\n    access_token: this.accessToken,\n    language: options.language,\n    limit: options.limit,\n    navigation_profile: options.navigation_profile,\n    route: options.route,\n    route_geometry: options.route_geometry,\n    sar_type: options.sar_type,\n    time_deviation: options.time_deviation,\n    eta_type: options.eta_type,\n    country: options.country,\n    poi_category: options.poi_category,\n    radius: options.radius,\n    user_id: options.user_id,\n    rich_metadata_provider: options.rich_metadata_provider,\n    poi_category_exclusions: options.poi_category_exclusions\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.origin && {\n    origin: typeof options.origin === \"string\" ? options.origin : LngLat.convert(options.origin).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n};\nSearchBoxCore.defaults = {\n  language: \"en\"\n};\n\n// src/validate/constants.ts\nvar SEARCH_URL3 = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_VALIDATE = \"retrieve\";\nvar VALIDATE_URL = `${SEARCH_URL3}/${ENDPOINT_VALIDATE}`;\n\n// src/validate/ValidationCore.ts\nvar _getQueryParams3, getQueryParams_fn3;\nvar _ValidationCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams3);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _ValidationCore.defaults), defaults);\n  }\n  validate(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n      const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams3, getQueryParams_fn3).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      if (json.features.length > 0) {\n        json.features = [json.features[0]];\n      }\n      return json;\n    });\n  }\n};\nvar ValidationCore = _ValidationCore;\n_getQueryParams3 = new WeakSet();\ngetQueryParams_fn3 = function(options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\nValidationCore.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n};\n\n// src/geocode/constants.ts\nvar SEARCH_URL4 = `https://api.mapbox.com/geocoding/v5`;\nvar TEMP_URL = `${SEARCH_URL4}/mapbox.places`;\nvar PERMANENT_URL = `${SEARCH_URL4}/mapbox.places-permanent`;\n\n// src/geocode/GeocodingCore.ts\nvar _getQueryParams4, getQueryParams_fn4;\nvar GeocodingCore = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams4);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues({}, defaults);\n  }\n  forward(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      let signal;\n      if (optionsArg) {\n        ({ signal } = optionsArg);\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n      url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options);\n      const { fetch } = getFetch();\n      const fetchInit = signal ? { signal } : {};\n      const res = yield fetch(url.toString(), fetchInit);\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n  reverse(lngLat, optionsArg) {\n    return __async(this, null, function* () {\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n      let signal;\n      if (optionsArg) {\n        ({ signal } = optionsArg);\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const searchText = typeof lngLat === \"string\" ? lngLat : LngLat.convert(lngLat).toArray().join(\",\");\n      const baseUrl = options.permanent ? PERMANENT_URL : TEMP_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}.json`);\n      url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options, true);\n      const { fetch } = getFetch();\n      const fetchInit = signal ? { signal } : {};\n      const res = yield fetch(url.toString(), fetchInit);\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      json.url = url.toString();\n      return json;\n    });\n  }\n};\n_getQueryParams4 = new WeakSet();\ngetQueryParams_fn4 = function(options, isReverse = false) {\n  if (isReverse) {\n    [\"proximity\", \"autocomplete\", \"fuzzyMatch\", \"bbox\"].forEach((key) => {\n      if (key in options) {\n        delete options[key];\n      }\n    });\n  }\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    autocomplete: options.autocomplete,\n    fuzzyMatch: options.fuzzyMatch,\n    routing: options.routing,\n    worldview: options.worldview\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n};\n\n// src/types.ts\nvar MatchCodeConfidence = /* @__PURE__ */ ((MatchCodeConfidence2) => {\n  MatchCodeConfidence2[\"exact\"] = \"exact\";\n  MatchCodeConfidence2[\"high\"] = \"high\";\n  MatchCodeConfidence2[\"medium\"] = \"medium\";\n  MatchCodeConfidence2[\"low\"] = \"low\";\n  return MatchCodeConfidence2;\n})(MatchCodeConfidence || {});\n\n// src/utils/Evented.ts\nvar _listeners;\nvar Evented = class {\n  constructor() {\n    __privateAdd(this, _listeners, {});\n  }\n  addEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n    listenersArr[type].push(listener);\n  }\n  removeEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      return;\n    }\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n  fire(type, arg0) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      return;\n    }\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n};\n_listeners = new WeakMap();\n\n// src/utils/debounce.ts\nfunction debounce(func, wait, signalFn) {\n  let timeout = null;\n  return (...args) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal == null ? void 0 : signal.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  };\n}\n\n// src/SearchSession.ts\nfunction createAbortController() {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\nvar _suggestions, _abort, _suggestDebounce;\nvar SearchSession = class extends Evented {\n  constructor(search, wait = 0) {\n    super();\n    this.sessionToken = new SessionToken();\n    __privateAdd(this, _suggestions, void 0);\n    __privateAdd(this, _abort, createAbortController());\n    __privateAdd(this, _suggestDebounce, void 0);\n    __privateSet(this, _suggestDebounce, debounce((_0, ..._1) => __async(this, [_0, ..._1], function* (searchText, options = {}) {\n      __privateGet(this, _abort).abort();\n      __privateSet(this, _abort, createAbortController());\n      if (!searchText) {\n        __privateSet(this, _suggestions, null);\n        this.fire(\"suggest\", __privateGet(this, _suggestions));\n        return;\n      }\n      try {\n        const res = yield this.search.suggest(searchText, __spreadProps(__spreadValues({\n          sessionToken: this.sessionToken\n        }, options), {\n          signal: __privateGet(this, _abort).signal\n        }));\n        __privateSet(this, _suggestions, res);\n        this.fire(\"suggest\", res);\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          return;\n        }\n        this.fire(\"suggesterror\", err);\n      }\n    }), wait, () => __privateGet(this, _abort).signal));\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n  get suggestions() {\n    return __privateGet(this, _suggestions);\n  }\n  suggest(searchText, options) {\n    __privateGet(this, _suggestDebounce).call(this, searchText, options);\n    return new Promise((resolve, reject) => {\n      let suggestFn;\n      let suggestErrorFn;\n      suggestFn = (res) => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        reject(err);\n      };\n      this.addEventListener(\"suggest\", suggestFn);\n      this.addEventListener(\"suggesterror\", suggestErrorFn);\n    });\n  }\n  clear() {\n    this.suggest(\"\");\n  }\n  retrieve(suggestion, options) {\n    return __async(this, null, function* () {\n      const res = yield this.search.retrieve(suggestion, __spreadValues({\n        sessionToken: this.sessionToken\n      }, options));\n      this.fire(\"retrieve\", res);\n      return res;\n    });\n  }\n  canRetrieve(suggestion) {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n    return this.search.canRetrieve(suggestion);\n  }\n  canSuggest(suggestion) {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n    return this.search.canSuggest(suggestion);\n  }\n  abort() {\n    __privateGet(this, _abort).abort();\n    __privateSet(this, _abort, createAbortController());\n  }\n};\n_suggestions = new WeakMap();\n_abort = new WeakMap();\n_suggestDebounce = new WeakMap();\n\n// src/featureToSuggestion.ts\nfunction featureToSuggestion(feature) {\n  const { properties } = feature;\n  return __spreadValues({}, properties);\n}\nexport {\n  AddressAutofillCore,\n  Evented,\n  GeocodingCore,\n  LngLat,\n  LngLatBounds,\n  AddressAutofillCore as MapboxAutofill,\n  MapboxError,\n  GeocodingCore as MapboxGeocode,\n  ValidationCore as MapboxValidate,\n  MatchCodeConfidence,\n  SearchBoxCore,\n  SearchSession,\n  SessionToken,\n  ValidationCore,\n  debounce,\n  featureToSuggestion,\n  polyfillFetch\n};\n//# sourceMappingURL=index-esm.js.map\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/utils/dom.ts\nvar subdoc = document.implementation.createHTMLDocument();\nfunction bindElements(root, elements) {\n  const binding = {};\n  for (const [key, selector] of Object.entries(elements)) {\n    binding[key] = root.querySelector(selector);\n  }\n  return binding;\n}\nfunction getChildElements(node) {\n  return Array.from(node.childNodes || []).filter((el) => el.nodeType === Node.ELEMENT_NODE);\n}\nfunction createElementFromString(innerHTML) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = innerHTML;\n  return template.content.firstElementChild;\n}\nfunction createCSSStyleSheet(text) {\n  const style = subdoc.createElement(\"style\");\n  style.textContent = text;\n  subdoc.head.appendChild(style);\n  return style.sheet;\n}\nfunction isVisible(element) {\n  const style = window.getComputedStyle(element);\n  return style.display !== \"none\";\n}\nfunction setValue(input, value) {\n  if (!input) {\n    return;\n  }\n  const set = Object.getOwnPropertyDescriptor(input.constructor.prototype, \"value\").set;\n  set.call(input, value);\n  const wrapperState = input;\n  if (wrapperState._valueTracker) {\n    wrapperState._valueTracker.setValue(\"\");\n  }\n  const onInputEvent = new Event(\"input\", {\n    bubbles: true\n  });\n  onInputEvent.simulated = true;\n  input.dispatchEvent(onInputEvent);\n  const onChangeEvent = new Event(\"change\", {\n    bubbles: true\n  });\n  onChangeEvent.simulated = true;\n  input.dispatchEvent(onChangeEvent);\n}\nfunction getElementSize(element, deep = false) {\n  let width;\n  let height;\n  const elementRect = element.getBoundingClientRect();\n  if (element.style.display === \"none\" || elementRect.height === 0 && elementRect.width === 0) {\n    const clone = element.cloneNode(deep);\n    element.parentElement.appendChild(clone);\n    clone.style.setProperty(\"display\", \"block\", \"important\");\n    const cloneRect = clone.getBoundingClientRect();\n    width = cloneRect.width;\n    height = cloneRect.height;\n    clone.style.setProperty(\"display\", \"none\");\n    clone.remove();\n  } else {\n    width = elementRect.width;\n    height = elementRect.height;\n  }\n  return {\n    height: Math.floor(height),\n    width: Math.floor(width)\n  };\n}\nfunction addDocumentStyle(css) {\n  const style = document.createElement(\"style\");\n  style.innerHTML = css;\n  document.head.appendChild(style);\n}\n\n// src/utils/class_name_transformers.ts\nvar IDENTIFIER_REGEX = new RegExp(\"[_a-zA-Z]+[_a-zA-Z0-9-]*\", \"g\");\nvar CLASS_NAME_REGEX = new RegExp(`\\\\.${IDENTIFIER_REGEX.source}`, \"g\");\nvar CONDITION_RULE_REGEX = new RegExp(`^\\\\s*(@(?:media|supports)[^{]*){(.*)}\\\\s*$`);\nfunction transformClassSelectors(css, transform) {\n  return css.replace(CLASS_NAME_REGEX, (className) => {\n    return \".\" + transform(className.slice(1));\n  });\n}\nfunction transformCSSClassRules(text, transform) {\n  const sheet = createCSSStyleSheet(text);\n  const rules = sheet.cssRules;\n  function transformCSSRule(rule) {\n    if (rule instanceof CSSStyleRule) {\n      const selector = transformClassSelectors(rule.selectorText, transform);\n      return `${selector} { ${rule.style.cssText} }`;\n    }\n    const atRule = CONDITION_RULE_REGEX.exec(rule.cssText.split(\"\\n\").join(\"\"));\n    if (atRule && atRule.length > 2) {\n      const rule2 = atRule[1];\n      const contents = atRule[2];\n      return `${rule2} { ${transformCSSClassRules(contents, transform)} }`;\n    }\n    return rule.cssText;\n  }\n  let style = \"\";\n  for (const rule of Array.from(rules)) {\n    style += transformCSSRule(rule) + \"\\n\\n\";\n  }\n  return style.trim();\n}\nfunction transformDOMClassAttributes(content, transform) {\n  const elements = Array.from(content.querySelectorAll(\"[class]\"));\n  elements.push(content);\n  for (const element of elements) {\n    const { classList } = element;\n    for (const className of Array.from(classList)) {\n      classList.remove(className);\n      classList.add(transform(className));\n    }\n  }\n  return content;\n}\n\n// src/utils/index.ts\nimport { SessionToken } from \"@mapbox/search-js-core\";\n\n// src/utils/map.ts\nvar FLY_TO_SPEED = 1.4;\nfunction bboxViewport(map, bounds, delta = 0.5) {\n  const { center, zoom } = map.cameraForBounds(bounds);\n  const transformedZoom = Math.max(zoom - delta, 0);\n  return {\n    center,\n    zoom: transformedZoom,\n    speed: FLY_TO_SPEED\n  };\n}\nfunction getMaxZoom(placeType) {\n  switch (placeType) {\n    case \"street\":\n      return 15;\n    case \"neighborhood\":\n    case \"postcode\":\n    case \"locality\":\n    case \"oaza\":\n      return 14;\n    case \"place\":\n    case \"city\":\n      return 13;\n    case \"district\":\n      return 9;\n    case \"region\":\n    case \"prefecture\":\n      return 6;\n    case \"country\":\n      return 4;\n    default:\n      return 16;\n  }\n}\nfunction getStaticBaseUrl(username, styleId) {\n  return `https://api.mapbox.com/styles/v1/${username}/${styleId}/static/`;\n}\n\n// src/icons/close.svg\nvar close_default = '<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3.8 3.8a1 1 0 0 1 1.4 0L9 7.58l3.8-3.8a1 1 0 1 1 1.4 1.42L10.42 9l3.8 3.8a1 1 0 0 1-1.42 1.4L9 10.42l-3.8 3.8a1 1 0 0 1-1.4-1.42L7.58 9l-3.8-3.8a1 1 0 0 1 0-1.4Z\" fill=\"currentColor\"/></svg>';\n\n// src/icons/loading.svg\nvar loading_default = '<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"#333\" d=\"M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z\"/><path opacity=\".1\" d=\"M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z\"/></svg>';\n\n// src/constants.ts\nvar STATIC_BASE_URL_SATELLITE = getStaticBaseUrl(\"mapbox\", \"satellite-streets-v11\");\nvar AUTOFILL_SKU_TOKEN_PREFIX = \"20d01\";\nvar MAPBOX_DOMAINS = [\"mapbox.com\", \"mapbox.cn\", \"tilestream.net\"];\nvar LISTBOX_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MapboxSearch\">\n    <div class=\"Label\" role=\"label\" aria-live=\"polite\" aria-atomic=\"true\">\n    </div>\n    <div class=\"Results\" aria-hidden=\"true\">\n      <div class=\"ResultsList\" role=\"listbox\">\n      </div>\n      <div class=\"ResultsAttribution\" aria-hidden=\"true\">\n        <a href=\"https://www.mapbox.com/search-service\" target=\"_blank\" tabindex=\"-1\">\n          Powered by Mapbox\n        </a>\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar LISTBOX_SUGGESTION_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"Suggestion\" role=\"option\" tabindex=\"-1\">\n    <div class=\"SuggestionIcon\" aria-hidden=\"true\"></div>\n    <div class=\"SuggestionText\">\n      <div class=\"SuggestionName\"></div>\n      <div class=\"SuggestionDesc\"></div>\n    </div>\n  </div>\n</template>\n`);\nvar SEARCHBOX_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"SearchBox\">\n    <div class=\"SearchIcon\"></div>\n    <input class=\"Input\" type=\"text\" />\n    <div class=\"ActionIcon\">\n      <button aria-label=\"Clear\" class=\"ClearBtn\">${close_default}</button>\n      <div class=\"LoadingIcon\">${loading_default}</div>\n    </div>\n  </div>\n</template>\n`);\n\n// src/utils/index.ts\nfunction randomValidID() {\n  return `mbx` + new SessionToken().id.slice(0, 8);\n}\nfunction tryParseJSON(json) {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n}\nfunction deepEquals(a, b) {\n  if (a == null || b == null) {\n    return a === b;\n  }\n  if (typeof a !== \"object\" || typeof b !== \"object\") {\n    return a === b;\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  for (const key of aKeys) {\n    if (!deepEquals(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction round(num, decimalPlaces) {\n  const factorOfTen = Math.pow(10, decimalPlaces);\n  return Math.round(num * factorOfTen) / factorOfTen;\n}\nfunction isLocalServer(hostname) {\n  return Boolean(hostname.match(/localhost|[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|::1|\\.local|^$/gi));\n}\nfunction isMapboxDomain(hostname) {\n  return Boolean(MAPBOX_DOMAINS.some((domain) => hostname.includes(domain)));\n}\n\n// src/components/HTMLScopedElement.ts\nvar _seed, _templateUserStyleElement, _transform;\nvar HTMLScopedElement = class extends HTMLElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _seed, randomValidID());\n    __privateAdd(this, _templateUserStyleElement, void 0);\n    __privateAdd(this, _transform, (className) => {\n      return `${__privateGet(this, _seed)}--${className}`;\n    });\n  }\n  get template() {\n    return null;\n  }\n  get templateStyle() {\n    return null;\n  }\n  get templateUserStyle() {\n    return null;\n  }\n  clonedCallback(oldSeed, newSeed) {\n    const seedTransform = (className) => className.replace(oldSeed, newSeed);\n    transformDOMClassAttributes(this, seedTransform);\n    const styles = Array.from(this.querySelectorAll(\"style\"));\n    for (const style of styles) {\n      style.textContent = transformClassSelectors(style.textContent, seedTransform);\n    }\n    if (styles.length) {\n      __privateSet(this, _templateUserStyleElement, styles[styles.length - 1]);\n    }\n    const nodesWithId = Array.from(this.querySelectorAll(`[id^=\"${oldSeed}\"]`));\n    for (const node of nodesWithId) {\n      node.id = node.id.replace(oldSeed, newSeed);\n    }\n  }\n  connectedCallback() {\n    if (this.childElementCount > 0) {\n      const oldSeed = this.dataset.seed;\n      const newSeed = __privateGet(this, _seed);\n      if (oldSeed && oldSeed !== newSeed) {\n        this.clonedCallback(oldSeed, newSeed);\n        this.dataset.seed = newSeed;\n      }\n      return;\n    }\n    this.dataset.seed = __privateGet(this, _seed);\n    const template = this.template;\n    if (template) {\n      const element = this.prepareTemplate(template);\n      this.appendChild(element);\n    }\n    const templateStyle = this.templateStyle;\n    if (templateStyle) {\n      const style = document.createElement(\"style\");\n      style.textContent = this.prepareCSS(templateStyle);\n      this.appendChild(style);\n    }\n    const userStyle = document.createElement(\"style\");\n    if (this.templateUserStyle) {\n      userStyle.textContent = this.prepareCSS(this.templateUserStyle);\n    }\n    this.appendChild(userStyle);\n    __privateSet(this, _templateUserStyleElement, userStyle);\n  }\n  prepareTemplate(template) {\n    const element = template.content.firstElementChild;\n    return transformDOMClassAttributes(element.cloneNode(true), __privateGet(this, _transform));\n  }\n  prepareCSS(css) {\n    return transformCSSClassRules(css, __privateGet(this, _transform));\n  }\n  updateTemplateUserStyle(style) {\n    if (!__privateGet(this, _templateUserStyleElement)) {\n      return;\n    }\n    __privateGet(this, _templateUserStyleElement).textContent = this.prepareCSS(style);\n  }\n  querySelector(selectors) {\n    return super.querySelector(transformClassSelectors(selectors, __privateGet(this, _transform)));\n  }\n  querySelectorAll(selectors) {\n    return super.querySelectorAll(transformClassSelectors(selectors, __privateGet(this, _transform)));\n  }\n  addEventListener(type, listener, options) {\n    super.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    super.removeEventListener(type, listener, options);\n  }\n  dispatchEvent(event) {\n    return super.dispatchEvent(event);\n  }\n};\n_seed = new WeakMap();\n_templateUserStyleElement = new WeakMap();\n_transform = new WeakMap();\n\n// src/icons/question.svg\nvar question_default = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 16A7 7 0 1 0 9 2a7 7 0 0 0 0 14ZM6.88 4.88a2.58 2.58 0 0 1 1.83-.75h1.08a2.58 2.58 0 0 1 2.59 2.58v.16c0 1-.53 1.94-1.4 2.46l-.56.34c-.27.16-.45.42-.52.71-.03.14-.14.25-.28.25H8.38a.23.23 0 0 1-.24-.25c.08-.91.59-1.74 1.38-2.21l.56-.34c.34-.2.54-.57.54-.96V6.7a.83.83 0 0 0-.83-.83H8.71a.83.83 0 0 0-.84.83v.18a.87.87 0 1 1-1.75 0V6.7c0-.69.28-1.34.76-1.83ZM10 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z\" fill=\"currentColor\"/></svg>';\n\n// src/icons/marker.svg\nvar marker_default = '<svg width=\"48\" height=\"56\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><g filter=\"url(#a)\"><path d=\"m24 50.4 13.79-14.12a18.82 18.82 0 0 0 4.23-20.86 19.23 19.23 0 0 0-7.19-8.6 19.76 19.76 0 0 0-21.66 0c-3.21 2.11-5.71 5.1-7.19 8.6a18.82 18.82 0 0 0 4.23 20.86L24 50.4Z\" fill=\"currentColor\"/><path d=\"M37.26 35.75 24 49.34 10.75 35.76l-.01-.01A18.07 18.07 0 0 1 6.68 15.7a18.48 18.48 0 0 1 6.9-8.26 19 19 0 0 1 20.84 0 18.48 18.48 0 0 1 6.9 8.26 18.07 18.07 0 0 1-4.06 20.04Z\" stroke=\"#fff\" stroke-width=\"1.5\"/></g><circle cx=\"24\" cy=\"22.45\" fill=\"#fff\" r=\"5.85\"/><defs><filter id=\"a\" x=\".5\" y=\".6\" width=\"47\" height=\"54.8\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"/><feColorMatrix in=\"SourceAlpha\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\"/><feOffset dy=\"1\"/><feGaussianBlur stdDeviation=\"2\"/><feColorMatrix values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0\"/><feBlend in2=\"BackgroundImageFix\" result=\"effect1_dropShadow_17_871\"/><feBlend in=\"SourceGraphic\" in2=\"effect1_dropShadow_17_871\" result=\"shape\"/></filter></defs></svg>';\n\n// src/icons/street.svg\nvar street_default = '<svg width=\"24\" height=\"24\" viewBox=\"0 0 18 18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M1.08 14.94 5.625 3.06h1.17l-3.42 11.88H1.08Zm15.885 0L12.42 3.06h-1.17l3.42 11.88h2.295Zm-6.86-1.44H7.946l.128-2.61h1.912l.119 2.61Zm-.217-4.77H8.181l.088-1.8h1.537l.082 1.8ZM9.74 5.49h-1.4l.049-.99h1.306l.045.99Z\" fill=\"currentColor\" />\\n</svg>';\n\n// src/icons/addressMarker.svg\nvar addressMarker_default = `<!-- TODO: I'm not sure if the way I added the circle will \"scale\" properly, need to check that -->\n<svg width=\"24\" height=\"24\" viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.5\" d=\"M4 7a5 5 0 1 1 10 0c0 3.025-3.28 6.713-5 9-1.72-2.287-5-5.975-5-9z\"></path>\n    <circle cx=\"9\" cy=\"7\" r=\"2\" fill=\"currentColor\"></circle>\n</svg>`;\n\n// src/icons/search.svg\nvar search_default = '<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\\n  <path d=\"M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z\"/>\\n</svg>';\n\n// package.json\nvar version = \"1.0.0-beta.17\";\n\n// src/theme.ts\nvar styleToggleSatelliteImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-satellite.jpg`;\nvar styleToggleDefaultImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-default.jpg`;\nvar MOBILE_BREAKPOINT = 768 - 1;\nvar MOBILE_MEDIA_QUERY = `@media only screen and (max-width: ${MOBILE_BREAKPOINT}px)`;\nvar DEFAULT_THEME = {\n  variables: {\n    unit: [\"mobile\", \"16px\", \"14px\"],\n    unitHeader: [\"mobile\", \"24px\", \"18px\"],\n    minWidth: \"min(300px, 100vw)\",\n    spacing: \"0.75em\",\n    padding: \"0.5em 0.75em\",\n    paddingFooterLabel: \"0.5em 0.75em\",\n    paddingModal: \"1.25em\",\n    colorText: \"rgba(0, 0, 0, 0.75)\",\n    colorPrimary: \"#4264FB\",\n    colorSecondary: \"#667F91\",\n    colorBackground: \"#fff\",\n    colorBackgroundHover: \"#f5f5f5\",\n    colorBackgroundActive: \"#f0f0f0\",\n    colorBackdrop: \"rgba(102, 127, 145, 0.3)\",\n    border: \"none\",\n    borderRadius: \"4px\",\n    boxShadow: `\n      0 0 10px 2px rgba(0, 0, 0, 0.05),\n      0 0 6px 1px rgba(0, 0, 0, 0.1),\n      0 0 0 1px rgba(0, 0, 0, 0.1)\n    `,\n    lineHeight: \"1.2em\",\n    fontFamily: `\n      -apple-system, BlinkMacSystemFont,\n      avenir next, avenir,\n      segoe ui,\n      helvetica neue, helvetica,\n      Ubuntu, roboto, noto, arial, sans-serif\n    `,\n    fontWeight: \"normal\",\n    fontWeightSemibold: \"600\",\n    fontWeightBold: \"bold\",\n    duration: \"150ms\",\n    curve: \"ease-out\"\n  },\n  icons: {\n    close: close_default,\n    question: question_default,\n    marker: marker_default,\n    street: street_default,\n    addressMarker: addressMarker_default,\n    search: search_default\n  },\n  images: {\n    styleToggleDefault: styleToggleDefaultImg,\n    styleToggleSatellite: styleToggleSatelliteImg\n  }\n};\nfunction getThemeCSS(rootSelector, theme = {}) {\n  const variables = __spreadValues(__spreadValues({}, DEFAULT_THEME.variables), theme.variables || {});\n  let cssText = theme.cssText || \"\";\n  let rootVariables = \"\";\n  for (const [key, value] of Object.entries(variables)) {\n    if (!Array.isArray(value)) {\n      rootVariables += `--${key}: ${value};`;\n      continue;\n    }\n    if (value[0] !== \"mobile\") {\n      const valueStr = JSON.stringify(value);\n      throw new Error(`Unsupported expression in theme variables: ${key} ${valueStr}`);\n    }\n    const [, mobileValue, desktopValue] = value;\n    cssText += `${MOBILE_MEDIA_QUERY} { ${rootSelector} { --${key}: ${mobileValue} !important; } }`;\n    rootVariables += `--${key}: ${desktopValue};`;\n  }\n  return cssText + `${rootSelector} { ${rootVariables} }`;\n}\nfunction getIcon(iconName, theme = {}) {\n  const icons = __spreadValues(__spreadValues({}, DEFAULT_THEME.icons), theme.icons || {});\n  const svgString = icons[iconName];\n  return svgString;\n}\nfunction getImage(imageName, theme = {}) {\n  const images = __spreadValues(__spreadValues({}, DEFAULT_THEME.images), theme.images || {});\n  const imgString = images[imageName];\n  return imgString;\n}\n\n// src/utils/popover.ts\nimport {\n  computePosition,\n  autoUpdate,\n  flip,\n  offset\n} from \"@floating-ui/dom\";\nvar _options, _defaultOptions;\nvar Popover = class {\n  constructor(referenceEl, floatingEl, options) {\n    __privateAdd(this, _options, void 0);\n    __privateAdd(this, _defaultOptions, {\n      placement: \"bottom-start\",\n      flip: false,\n      offset: 10\n    });\n    this.update = () => __async(this, null, function* () {\n      const config2 = {\n        placement: this.options.placement,\n        middleware: [\n          offset(this.options.offset),\n          this.options.flip && flip()\n        ].filter(Boolean)\n      };\n      const { x, y } = yield computePosition(this.referenceEl, this.floatingEl, config2);\n      Object.assign(this.floatingEl.style, {\n        left: `${x}px`,\n        top: `${y}px`\n      });\n    });\n    this.referenceEl = referenceEl;\n    this.floatingEl = floatingEl;\n    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _defaultOptions)), options));\n    this.destroy = autoUpdate(this.referenceEl, this.floatingEl, this.update);\n  }\n  get options() {\n    return __privateGet(this, _options);\n  }\n  set options(newOptions) {\n    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _options)), newOptions));\n  }\n};\n_options = new WeakMap();\n_defaultOptions = new WeakMap();\n\n// src/style.css\nvar style_default = \"*{box-sizing:border-box!important}[role=button]{cursor:pointer}.MapboxSearch{--width:0;display:none}.Results{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);min-width:var(--minWidth);overflow-y:auto;position:absolute;transform:translateZ(0);transition:visibility var(--duration);width:var(--width);z-index:1000}.Results:not([aria-hidden=true]){visibility:visible}.Results[aria-hidden=true]{animation:fadein var(--duration) var(--curve) reverse forwards;visibility:hidden}.Suggestion{align-items:center;display:flex;padding:var(--padding)}.Suggestion:hover{cursor:pointer}.Suggestion[aria-selected=true]{background-color:var(--colorBackgroundHover)}.Suggestion:active{background-color:var(--colorBackgroundActive)}.SuggestionName{font-weight:var(--fontWeightBold)}.SuggestionIcon{margin-right:6px}.SuggestionIcon[aria-hidden=true]{display:none}.ResultsAttribution{padding:var(--paddingFooterLabel)}.ResultsAttribution a{color:var(--colorSecondary)}.ResultsAttribution a:not(:hover){text-decoration:none}.ResultsList{list-style:none;margin:0;padding:0}.Label{display:none}.SearchBox{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--padding);padding-bottom:0;padding-top:0;position:relative;width:100%}.SearchIcon{fill:#757575;left:.5em}.ActionIcon,.SearchIcon{bottom:0;height:20px;margin:auto 0;position:absolute;top:0;width:20px}.ActionIcon{right:.5em}.ActionIcon>button{background:none;border:none;color:inherit;cursor:pointer;font:inherit;height:100%;outline:inherit;padding:0;width:100%}.ActionIcon>button:hover{background:none!important}.ClearBtn{display:none}.ClearBtn:hover{color:#909090}.LoadingIcon{-moz-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;-webkit-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;display:none;height:100%}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.Input{background-color:transparent;border:0;color:#404040;color:rgba(0,0,0,.75);font:inherit;height:36px;margin:0;overflow:hidden;padding:0 40px;text-overflow:ellipsis;white-space:nowrap;width:100%}.Input::-ms-clear{display:none}.Input:focus{border:thin dotted;border-radius:var(--borderRadius);box-shadow:none;color:#404040;color:rgba(0,0,0,.75);outline:0}mapbox-address-confirmation-feature[aria-hidden=true],mapbox-address-confirmation-no-feature[aria-hidden=true]{display:none}.MapboxAddressConfirmation{align-items:center;background-color:var(--colorBackdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;transform:translateZ(0);z-index:1000}.MapboxAddressConfirmation:not([aria-hidden=true]){animation:fadein var(--duration) var(--curve) forwards;visibility:visible}.MapboxAddressConfirmation[aria-hidden=true]{visibility:hidden}.ContentFeature,.ContentNoFeature{width:var(--minWidth)}.Modal{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--paddingModal);width:100%}@media screen and (max-width:480px){.MapboxAddressConfirmation{align-items:flex-end}.ContentFeature,.ContentNoFeature{width:100%}.Modal{border-bottom-left-radius:0;border-bottom-right-radius:0}}.ModalHeader{align-items:center;color:var(--colorPrimary);display:flex;font-size:var(--unitHeader);font-weight:var(--fontWeightBold);margin-bottom:var(--spacing);user-select:none;width:100%}.ModalMap{height:calc(var(--minWidth)*9/16);margin-left:calc(var(--paddingModal)*-1);width:calc(100% + var(--paddingModal)*2)}.ModalMap[aria-hidden=true]{display:none}.Icon{height:var(--unitHeader);width:var(--unitHeader)}.Icon.IconClose{color:var(--colorSecondary)}.ModalHeaderTitle{flex:1;margin-left:.25em}.ModalFooter{color:var(--colorSecondary);margin-top:var(--spacing);text-align:center}.ModalFooter[aria-hidden=true]{display:none}.ModalSubheader{font-weight:var(--fontWeightBold);user-select:none}.ModalDescription{color:var(--colorPrimary)}.ModalAddress,.ModalSubheader{margin-bottom:var(--spacing)}.ModalAddress.ModalAddressApprove{color:var(--colorPrimary)}.Button{border-radius:var(--borderRadius);cursor:pointer;font-weight:var(--fontWeightSemibold);margin-top:var(--spacing);padding:var(--padding);text-align:center;user-select:none;width:100%}.Button[aria-hidden=true]{display:none}.Button.ButtonPrimary{background-color:var(--colorPrimary);color:var(--colorBackground)}.Button.ButtonSecondary{border:1px solid var(--colorSecondary);color:var(--colorSecondary)}@keyframes fadein{0%{opacity:0}to{opacity:1}}.MapboxAddressMinimap{font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight)}.MapboxAddressMinimap[aria-hidden=true]{display:none}.MinimapImageContainer{border-radius:var(--borderRadius);overflow:hidden}.MinimapImage{height:unset;max-height:unset;max-width:unset;position:relative;width:unset}.MinimapInnerFrame{border:var(--border);border-radius:inherit;height:inherit;left:0;overflow:hidden;position:absolute;top:0;width:inherit}.MinimapMarker{left:50%;position:absolute;top:50%}.MinimapMarker>svg{color:var(--colorPrimary);display:block!important}.MinimapAttributionLogo{bottom:0;left:0;margin:0 0 6px 6px;position:absolute}.MinimapAttributionLogo a{cursor:pointer;display:block;height:23px;width:88px}.MinimapAttributionText{background-color:hsla(0,0%,100%,.65);bottom:0;font:11px/16px Helvetica Neue,Arial,Helvetica,sans-serif;padding:0 5px;position:absolute;right:0}.MinimapAttributionText a{color:rgba(0,0,0,.75);text-decoration:none}.MinimapAttributionText a:hover{color:inherit;text-decoration:underline}.MinimapAttributionText a:not(:first-child){margin-left:3px}.MinimapStyleToggle{background-position:0;background-repeat:no-repeat;background-size:contain;border:2px solid #fff;border-radius:3px;box-shadow:var(--boxShadow);cursor:pointer;height:2em;position:absolute;right:var(--spacing);top:var(--spacing);width:2em}.MinimapFooter{color:var(--colorSecondary);font-family:var(--fontFamily);font-size:var(--unit);margin-top:var(--spacing)}.MinimapFooter[aria-hidden=true]{display:none}.MinimapEditButtons{bottom:26px;display:flex;font-family:var(--fontFamily);position:absolute;right:var(--spacing)}.MinimapEditButtons .Button{box-shadow:var(--boxShadow)}.MinimapButtonCancel{background-color:var(--colorBackground);margin-left:var(--spacing)}.draggable{cursor:move;cursor:grab}.draggable:active{cursor:grabbing}\";\n\n// src/MapboxHTMLEvent.ts\nvar MapboxHTMLEvent = class extends CustomEvent {\n  constructor(type, detail) {\n    super(type, {\n      composed: true,\n      detail\n    });\n  }\n  clone(newTarget) {\n    const eventClone = new MapboxHTMLEvent(this.type, this.detail);\n    if (newTarget) {\n      Object.defineProperty(eventClone, \"target\", { value: newTarget });\n    }\n    return eventClone;\n  }\n};\n\n// src/utils/aria/messages.ts\nvar LENGTH_MESSAGE = \"Type in 2 or more characters for results.\";\nvar KEYBOARD_NAVIGATION_GUIDE_MESSAGE = \"When autocomplete results are available use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.\";\nvar NO_SEARCH_RESULTS_MESSAGE = \"No search results.\";\nvar getSuggestionSelectedMessage = (address, numberOfResults, currentIndex) => `${numberOfResults} ${numberOfResults === 1 ? \"result is\" : \"results are\"} available. ${address}. ${currentIndex} of ${numberOfResults} is selected.`;\nvar getSuggestionsReadyMessage = (numberOfResults) => `${numberOfResults} ${numberOfResults === 1 ? \"result is\" : \"results are\"} available. Use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.`;\n\n// src/utils/aria/index.ts\nfunction ariaButtonKeyDown(e) {\n  const el = e.currentTarget;\n  if (e.key === \" \" || e.key === \"Enter\") {\n    e.preventDefault();\n    e.stopPropagation();\n    el.dispatchEvent(new MouseEvent(\"click\", {\n      bubbles: true,\n      composed: true\n    }));\n  }\n}\nvar ARIA_DESCRIPTION_ID = \"search-listbox__description\";\nvar createAriaLiveElement = (seed) => {\n  const container = document.createElement(\"div\");\n  container.setAttribute(\"aria-live\", \"polite\");\n  container.setAttribute(\"aria-atomic\", \"true\");\n  container.setAttribute(\"role\", \"status\");\n  container.setAttribute(\"style\", \"border: 0px;clip: rect(0px, 0px, 0px, 0px);height: 1px;margin-bottom: -1px;margin-right: -1px;overflow: hidden;padding: 0px;position: absolute;white-space: nowrap;width: 1px;\");\n  const description = document.createElement(\"div\");\n  description.setAttribute(\"id\", `${seed}--${ARIA_DESCRIPTION_ID}`);\n  container.appendChild(description);\n  return container;\n};\nvar setLiveRegionMessage = (message, seed) => {\n  var _a;\n  const description = (_a = document.body.querySelector(`[id=\"${seed}--${ARIA_DESCRIPTION_ID}\"]`)) != null ? _a : null;\n  if (description) {\n    description.textContent = message;\n  }\n};\nvar suppressExtensionsAutocomplete = (input) => {\n  input.name = input.name + \" address-search\";\n  input.setAttribute(\"data-lpignore\", \"true\");\n};\nvar getAriaMessage = (searchValue, suggestions, selectedIndex) => {\n  let ariaMessage = null;\n  const noResults = !suggestions || suggestions.length === 0;\n  if ((searchValue == null ? void 0 : searchValue.length) < 2) {\n    ariaMessage = LENGTH_MESSAGE + \" \" + KEYBOARD_NAVIGATION_GUIDE_MESSAGE;\n  } else if (noResults) {\n    ariaMessage = NO_SEARCH_RESULTS_MESSAGE;\n  } else if (selectedIndex !== void 0) {\n    const suggestion = suggestions[selectedIndex];\n    const placeName = suggestion.address || suggestion.full_address || suggestion.feature_name;\n    ariaMessage = getSuggestionSelectedMessage(placeName, suggestions.length, selectedIndex + 1);\n  } else {\n    ariaMessage = getSuggestionsReadyMessage(suggestions.length);\n  }\n  return ariaMessage;\n};\n\n// src/utils/listbox.ts\nvar getSuggestionTitle = (item, service) => {\n  switch (service) {\n    case 0 /* AddressAutofill */:\n      return item.address_line1 || item.matching_name || item.feature_name;\n    case 3 /* SearchBox */:\n      return item.name;\n    case 1 /* GeocodingV5 */:\n      return item.place_name.split(\",\")[0];\n    default:\n      return \"\";\n  }\n};\nvar buildSuggestionDescription = (item, service) => {\n  switch (service) {\n    case 0 /* AddressAutofill */:\n      return item.description;\n    case 3 /* SearchBox */:\n      if (item.feature_type === \"poi\") {\n        return item.full_address;\n      }\n      return item.place_formatted;\n    case 1 /* GeocodingV5 */:\n      return item.place_name.split(\",\").splice(1).join(\",\").trim();\n    default:\n      return \"\";\n  }\n};\n\n// src/components/MapboxSearchListbox.ts\nfunction getAriaIdForSuggestion(resultListId, i) {\n  return `${resultListId}-${i}`;\n}\nvar _popover, _binding, _labelID, _resultListID, _inputInternal, _searchService, _selectedIndexInternal, _showResults, showResults_fn, _renderResultsList, renderResultsList_fn, _themeInternal, _popoverOptions, _handleInput, _handleSelect, _handleFocus, _handleBlur, _handleKeyDown;\nvar MapboxSearchListbox = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _showResults);\n    __privateAdd(this, _renderResultsList);\n    this.suggestions = null;\n    __privateAdd(this, _popover, null);\n    __privateAdd(this, _binding, void 0);\n    __privateAdd(this, _labelID, void 0);\n    __privateAdd(this, _resultListID, void 0);\n    __privateAdd(this, _inputInternal, void 0);\n    __privateAdd(this, _searchService, null);\n    __privateAdd(this, _selectedIndexInternal, void 0);\n    __privateAdd(this, _themeInternal, {});\n    __privateAdd(this, _popoverOptions, {});\n    __privateAdd(this, _handleInput, (e) => {\n      const { Results } = __privateGet(this, _binding);\n      const input = e.target;\n      if (input.dataset[\"mapboxSuccess\"]) {\n        delete input.dataset[\"mapboxSuccess\"];\n        return;\n      }\n      const searchText = input.value;\n      this.renderAriaMessage();\n      Results.setAttribute(\"aria-busy\", \"true\");\n      this.dispatchEvent(new MapboxHTMLEvent(\"input\", searchText));\n    });\n    this.renderAriaMessage = () => {\n      var _a;\n      const message = getAriaMessage((_a = this.input) == null ? void 0 : _a.value, this.suggestions, this.selectedIndex);\n      setLiveRegionMessage(message, this.dataset.seed);\n    };\n    this.clearAriaMessage = () => {\n      setLiveRegionMessage(\"\", this.dataset.seed);\n    };\n    this.handleSuggest = (suggestions) => {\n      this.suggestions = suggestions;\n      if (!suggestions || suggestions.length === 0) {\n        this.renderAriaMessage();\n      }\n      if (!suggestions) {\n        this.hideResults();\n        return;\n      }\n      __privateMethod(this, _renderResultsList, renderResultsList_fn).call(this);\n      if (suggestions.length) {\n        __privateMethod(this, _showResults, showResults_fn).call(this);\n      }\n      const { Results } = __privateGet(this, _binding);\n      Results.setAttribute(\"aria-busy\", \"false\");\n    };\n    this.handleError = () => {\n      const { Results } = __privateGet(this, _binding);\n      Results.setAttribute(\"aria-busy\", \"false\");\n      this.hideResults();\n    };\n    __privateAdd(this, _handleSelect, (suggestion) => __async(this, null, function* () {\n      const input = this.input;\n      if (input) {\n        input.dataset[\"mapboxSuccess\"] = \"true\";\n      }\n      this.dispatchEvent(new MapboxHTMLEvent(\"select\", suggestion));\n      this.hideResults();\n    }));\n    __privateAdd(this, _handleFocus, () => {\n      const input = this.input;\n      delete input.dataset[\"mapboxSuccess\"];\n      this.dispatchEvent(new MapboxHTMLEvent(\"focus\"));\n      this.renderAriaMessage();\n      __privateMethod(this, _showResults, showResults_fn).call(this);\n    });\n    __privateAdd(this, _handleBlur, () => {\n      if (document.activeElement === this.input) {\n        return;\n      }\n      this.dispatchEvent(new MapboxHTMLEvent(\"blur\"));\n      this.clearAriaMessage();\n      this.hideResults();\n    });\n    this.handleArrowUp = () => {\n      if (this.selectedIndex === void 0) {\n        this.selectedIndex = this.suggestions.length - 1;\n      } else if (this.selectedIndex === 0) {\n        this.selectedIndex = void 0;\n      } else {\n        this.selectedIndex = Math.max(0, this.selectedIndex - 1);\n      }\n    };\n    this.handleArrowDown = () => {\n      if (this.selectedIndex === void 0) {\n        this.selectedIndex = 0;\n      } else if (this.selectedIndex === this.suggestions.length - 1) {\n        this.selectedIndex = void 0;\n      } else {\n        this.selectedIndex = Math.min(this.selectedIndex + 1, this.suggestions.length - 1);\n      }\n    };\n    __privateAdd(this, _handleKeyDown, (e) => {\n      var _a;\n      if (!((_a = this.suggestions) == null ? void 0 : _a.length))\n        return;\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        this.handleArrowDown();\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        this.handleArrowUp();\n        return;\n      }\n      if (e.key === \"Escape\") {\n        this.hideResults();\n        return;\n      }\n      if (this.selectedIndex === void 0) {\n        return;\n      }\n      if (e.key === \"Tab\") {\n        __privateGet(this, _handleSelect).call(this, this.suggestions[this.selectedIndex]);\n        return;\n      }\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n        __privateGet(this, _handleSelect).call(this, this.suggestions[this.selectedIndex]);\n        return;\n      }\n    });\n  }\n  get template() {\n    return LISTBOX_TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxSearch\", this.theme);\n  }\n  get input() {\n    return __privateGet(this, _inputInternal);\n  }\n  set input(newInput) {\n    const oldInput = __privateGet(this, _inputInternal);\n    if (oldInput) {\n      oldInput.removeEventListener(\"input\", __privateGet(this, _handleInput));\n      oldInput.removeEventListener(\"focus\", __privateGet(this, _handleFocus));\n      oldInput.removeEventListener(\"blur\", __privateGet(this, _handleBlur));\n      oldInput.removeEventListener(\"keydown\", __privateGet(this, _handleKeyDown));\n      if (__privateGet(this, _popover)) {\n        __privateGet(this, _popover).destroy();\n      }\n    }\n    if (newInput) {\n      newInput.addEventListener(\"input\", __privateGet(this, _handleInput));\n      newInput.addEventListener(\"focus\", __privateGet(this, _handleFocus));\n      newInput.addEventListener(\"blur\", __privateGet(this, _handleBlur));\n      newInput.addEventListener(\"keydown\", __privateGet(this, _handleKeyDown));\n      newInput.setAttribute(\"role\", \"combobox\");\n      newInput.setAttribute(\"aria-autocomplete\", \"list\");\n      newInput.setAttribute(\"aria-controls\", __privateGet(this, _resultListID));\n      if (this.isConnected) {\n        __privateSet(this, _popover, new Popover(newInput, __privateGet(this, _binding).Results, this.popoverOptions));\n      }\n    }\n    __privateSet(this, _inputInternal, newInput);\n  }\n  get searchService() {\n    return __privateGet(this, _searchService);\n  }\n  set searchService(service) {\n    __privateSet(this, _searchService, service);\n  }\n  get selectedIndex() {\n    return __privateGet(this, _selectedIndexInternal);\n  }\n  set selectedIndex(newIndex) {\n    const oldIndex = __privateGet(this, _selectedIndexInternal);\n    __privateSet(this, _selectedIndexInternal, newIndex);\n    const { ResultsList } = __privateGet(this, _binding);\n    const id = getAriaIdForSuggestion(__privateGet(this, _resultListID), newIndex);\n    if (newIndex !== void 0) {\n      this.input.setAttribute(\"aria-activedescendant\", id);\n      ResultsList.setAttribute(\"aria-activedescendant\", id);\n    } else {\n      this.input.removeAttribute(\"aria-activedescendant\");\n      ResultsList.removeAttribute(\"aria-activedescendant\");\n    }\n    if (oldIndex !== newIndex) {\n      const oldId = getAriaIdForSuggestion(__privateGet(this, _resultListID), oldIndex);\n      const oldEl = ResultsList.querySelector(`#${oldId}`);\n      oldEl == null ? void 0 : oldEl.removeAttribute(\"aria-selected\");\n      oldEl == null ? void 0 : oldEl.setAttribute(\"tabindex\", \"-1\");\n      if (newIndex !== void 0) {\n        const el = ResultsList.querySelector(`#${id}`);\n        el == null ? void 0 : el.setAttribute(\"aria-selected\", \"true\");\n        el == null ? void 0 : el.setAttribute(\"tabindex\", \"0\");\n      }\n    }\n    this.renderAriaMessage();\n  }\n  hideResults() {\n    const { Results, ResultsList } = __privateGet(this, _binding);\n    Results.setAttribute(\"aria-hidden\", \"true\");\n    this.input.setAttribute(\"aria-expanded\", \"false\");\n    ResultsList.removeAttribute(\"aria-activedescendant\");\n    this.input.removeAttribute(\"aria-activedescendant\");\n  }\n  renderItem(i) {\n    const element = this.prepareTemplate(LISTBOX_SUGGESTION_TEMPLATE);\n    element.id = getAriaIdForSuggestion(__privateGet(this, _resultListID), i);\n    return element;\n  }\n  fillItem(el, item, i, totalLength) {\n    const iconEl = el.querySelector('[class$=\"SuggestionIcon\"]');\n    const nameEl = el.querySelector('[class$=\"SuggestionName\"]');\n    const descriptionEl = el.querySelector('[class$=\"SuggestionDesc\"]');\n    if (this.searchService === 0 /* AddressAutofill */) {\n      iconEl.innerHTML = getIcon(item.accuracy === \"street\" ? \"street\" : \"addressMarker\", this.theme);\n      iconEl.removeAttribute(\"aria-hidden\");\n    } else {\n      iconEl.setAttribute(\"aria-hidden\", \"true\");\n    }\n    nameEl.textContent = descriptionEl.textContent = \"\";\n    nameEl.textContent = getSuggestionTitle(item, this.searchService);\n    descriptionEl.textContent = buildSuggestionDescription(item, this.searchService);\n    if (i === this.selectedIndex) {\n      el.setAttribute(\"aria-selected\", \"true\");\n    } else {\n      el.removeAttribute(\"aria-selected\");\n    }\n    el.setAttribute(\"aria-posinset\", (i + 1).toString());\n    el.setAttribute(\"aria-setsize\", totalLength.toString());\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal, theme);\n    if (!__privateGet(this, _binding) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxSearch\", theme));\n  }\n  get popoverOptions() {\n    return __privateGet(this, _popoverOptions);\n  }\n  set popoverOptions(newOptions) {\n    __privateSet(this, _popoverOptions, newOptions);\n    if (__privateGet(this, _popover)) {\n      __privateGet(this, _popover).options = newOptions;\n      __privateGet(this, _popover).update();\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.dataSeed = this.dataset.seed;\n    __privateSet(this, _labelID, this.dataset.seed + \"-Label\");\n    __privateSet(this, _resultListID, this.dataset.seed + \"-ResultsList\");\n    if (this.input) {\n      this.input.setAttribute(\"aria-controls\", __privateGet(this, _resultListID));\n    }\n    __privateSet(this, _binding, bindElements(this, {\n      MapboxSearch: \".MapboxSearch\",\n      Results: \".Results\",\n      ResultsList: \".ResultsList\",\n      Label: \".Label\"\n    }));\n    const { Results, ResultsList, Label } = __privateGet(this, _binding);\n    Label.id = __privateGet(this, _labelID);\n    ResultsList.id = __privateGet(this, _resultListID);\n    ResultsList.setAttribute(\"aria-labelledby\", __privateGet(this, _labelID));\n    Results.addEventListener(\"blur\", __privateGet(this, _handleBlur));\n    if (!__privateGet(this, _popover) && this.input) {\n      __privateSet(this, _popover, new Popover(this.input, __privateGet(this, _binding).Results, this.popoverOptions));\n    }\n    requestAnimationFrame(() => {\n      if (__privateGet(this, _popover)) {\n        __privateGet(this, _popover).update();\n      }\n    });\n  }\n  disconnectedCallback() {\n    this.input = null;\n    const { Results } = __privateGet(this, _binding);\n    Results.removeEventListener(\"blur\", __privateGet(this, _handleBlur));\n    if (__privateGet(this, _popover))\n      __privateGet(this, _popover).destroy();\n  }\n  focus() {\n    if (document.activeElement === this.input) {\n      __privateGet(this, _handleFocus).call(this);\n    } else {\n      this.input.focus();\n    }\n  }\n  blur() {\n    this.input.blur();\n  }\n  updatePopover() {\n    if (__privateGet(this, _popover)) {\n      __privateGet(this, _popover).update();\n    }\n  }\n};\n_popover = new WeakMap();\n_binding = new WeakMap();\n_labelID = new WeakMap();\n_resultListID = new WeakMap();\n_inputInternal = new WeakMap();\n_searchService = new WeakMap();\n_selectedIndexInternal = new WeakMap();\n_showResults = new WeakSet();\nshowResults_fn = function() {\n  if (!this.suggestions || !this.suggestions.length) {\n    return;\n  }\n  const { Results, MapboxSearch } = __privateGet(this, _binding);\n  const rect = this.input.getBoundingClientRect();\n  MapboxSearch.style.setProperty(\"--width\", `${rect.width}px`);\n  MapboxSearch.style.setProperty(\"display\", \"block\");\n  this.input.setAttribute(\"aria-expanded\", \"true\");\n  Results.removeAttribute(\"aria-hidden\");\n  this.selectedIndex = void 0;\n};\n_renderResultsList = new WeakSet();\nrenderResultsList_fn = function() {\n  const { ResultsList } = __privateGet(this, _binding);\n  if (!this.suggestions || !this.suggestions.length) {\n    ResultsList.innerHTML = \"\";\n    this.hideResults();\n    return;\n  }\n  const elements = getChildElements(ResultsList);\n  if (this.suggestions.length > elements.length) {\n    for (let i = elements.length; i < this.suggestions.length; i++) {\n      const item = this.renderItem(i);\n      elements.push(item);\n      item.onmouseenter = () => {\n        this.selectedIndex = i;\n      };\n      item.onmouseleave = () => {\n        this.selectedIndex = void 0;\n      };\n      ResultsList.appendChild(item);\n    }\n  }\n  if (this.suggestions.length < elements.length) {\n    for (let i = this.suggestions.length; i < elements.length; i++) {\n      elements[i].remove();\n    }\n  }\n  for (const suggestion of this.suggestions) {\n    const i = this.suggestions.indexOf(suggestion);\n    const element = elements[i];\n    this.fillItem(element, suggestion, i, this.suggestions.length);\n    element.onclick = () => {\n      __privateGet(this, _handleSelect).call(this, suggestion);\n    };\n  }\n};\n_themeInternal = new WeakMap();\n_popoverOptions = new WeakMap();\n_handleInput = new WeakMap();\n_handleSelect = new WeakMap();\n_handleFocus = new WeakMap();\n_handleBlur = new WeakMap();\n_handleKeyDown = new WeakMap();\nwindow.MapboxSearchListbox = MapboxSearchListbox;\nif (!window.customElements.get(\"mapbox-search-listbox\")) {\n  customElements.define(\"mapbox-search-listbox\", MapboxSearchListbox);\n}\n\n// src/utils/autofill.ts\nimport {\n  featureToSuggestion\n} from \"@mapbox/search-js-core\";\nvar AUTOFILL_TOKENS = /* @__PURE__ */ new Set([\n  \"street-address\",\n  \"address-line1\",\n  \"address-line2\",\n  \"address-line3\",\n  \"address-level4\",\n  \"address-level3\",\n  \"address-level2\",\n  \"address-level1\",\n  \"country\",\n  \"country-name\",\n  \"postal-code\"\n]);\nvar AUTOFILL_SKIP_TOKENS = /* @__PURE__ */ new Set([\"off\", \"on\", \"true\", \"false\"]);\nfunction findParentForm(el) {\n  let node = el.parentNode;\n  while (node) {\n    if (node instanceof HTMLFormElement) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction findAddressInputs(form) {\n  const parent = form || document;\n  return Array.from(parent.querySelectorAll('input[autocomplete~=\"address-line1\"], input[autocomplete~=\"street-address\"]'));\n}\nvar SECTION = \"section-\";\nvar SECTION_DEFAULT = \"section-default\";\nvar SECTION_SHIPPING = \"section-shipping\";\nvar SECTION_BILLING = \"section-billing\";\nfunction parseFormStructure(form) {\n  const inputs = Array.from(form.querySelectorAll(\"[autocomplete]\")).filter((el) => {\n    const tagName = el.tagName.toLowerCase();\n    return tagName === \"input\" || tagName === \"select\" || tagName === \"textarea\";\n  });\n  const res = [];\n  for (const input of inputs) {\n    if (!isVisible(input)) {\n      continue;\n    }\n    const autocomplete = input.getAttribute(\"autocomplete\") || \"\";\n    if (!autocomplete || AUTOFILL_SKIP_TOKENS.has(autocomplete)) {\n      continue;\n    }\n    const tokens = autocomplete.toLowerCase().split(\" \");\n    if (tokens.length > 3) {\n      continue;\n    }\n    const field = tokens[tokens.length - 1];\n    if (!AUTOFILL_TOKENS.has(field)) {\n      continue;\n    }\n    tokens.pop();\n    let section = SECTION_DEFAULT;\n    if (tokens.length) {\n      const sectionToken = tokens[tokens.length - 1];\n      if (sectionToken === \"shipping\") {\n        section = SECTION_SHIPPING;\n        tokens.pop();\n      }\n      if (sectionToken === \"billing\") {\n        section = SECTION_BILLING;\n        tokens.pop();\n      }\n    }\n    if (tokens.length) {\n      const sectionToken = tokens[tokens.length - 1];\n      if (sectionToken.startsWith(SECTION)) {\n        section = sectionToken;\n      }\n    }\n    res.push({\n      input,\n      section,\n      field\n    });\n  }\n  return res;\n}\nfunction findAddressAutofillInputs(form, ref) {\n  const logicalSections = [];\n  const logicalSectionSections = [];\n  const formStructure = parseFormStructure(form);\n  let foundSection = null;\n  for (const { input, section, field } of formStructure) {\n    let lastIndex = logicalSections.length - 1;\n    let createNewSection = false;\n    if (!logicalSections.length) {\n      createNewSection = true;\n    } else if (logicalSectionSections[lastIndex] !== section) {\n      createNewSection = true;\n    } else if (logicalSections[lastIndex][field]) {\n      createNewSection = true;\n    }\n    if (createNewSection) {\n      if (foundSection) {\n        break;\n      }\n      logicalSections.push({\n        [field]: input\n      });\n      logicalSectionSections.push(section);\n      lastIndex++;\n    } else {\n      logicalSections[lastIndex][field] = input;\n    }\n    if (input === ref) {\n      foundSection = logicalSections[lastIndex];\n    }\n  }\n  return foundSection != null ? foundSection : {};\n}\nfunction setFormAutofillValues(form, ref, suggestion) {\n  var _a;\n  const map = findAddressAutofillInputs(form, ref);\n  const streetAddress = [\n    suggestion.address_line1,\n    suggestion.address_line2,\n    suggestion.address_line3\n  ].filter((part) => Boolean(part)).join(\", \");\n  setValue(map[\"street-address\"], streetAddress);\n  setValue(map[\"address-line1\"], suggestion.address_line1 || \"\");\n  setValue(map[\"address-level1\"], suggestion.address_level1 || \"\");\n  setValue(map[\"address-level2\"], suggestion.address_level2 || \"\");\n  setValue(map[\"address-level3\"], suggestion.address_level3 || \"\");\n  const countryCode = suggestion.country_code || ((_a = suggestion.metadata) == null ? void 0 : _a.iso_3166_1) || \"\";\n  if (map.country && map.country instanceof HTMLSelectElement) {\n    const firstOption = map.country.querySelector(`option`).value;\n    const isUpperCase = firstOption === firstOption.toUpperCase();\n    setValue(map[\"country\"], isUpperCase ? countryCode.toUpperCase() : countryCode);\n  } else {\n    setValue(map[\"country\"], countryCode);\n  }\n  setValue(map[\"country-name\"], suggestion.country || \"\");\n  setValue(map[\"postal-code\"], suggestion.postcode || \"\");\n}\nfunction getFormAutofillValues(form, ref) {\n  const map = findAddressAutofillInputs(form, ref);\n  const values = {};\n  for (const [key, input] of Object.entries(map)) {\n    if (input == null ? void 0 : input.value) {\n      values[key] = input.value;\n    }\n  }\n  return values;\n}\nfunction getAutofillSearchText(snapshot) {\n  const searchText = [];\n  if (snapshot[\"street-address\"]) {\n    searchText.push(snapshot[\"street-address\"]);\n  } else {\n    searchText.push(snapshot[\"address-line1\"] || \"\");\n    searchText.push(snapshot[\"address-line2\"] || \"\");\n    searchText.push(snapshot[\"address-line3\"] || \"\");\n  }\n  searchText.push(snapshot[\"address-level3\"] || \"\");\n  searchText.push(snapshot[\"address-level2\"] || \"\");\n  searchText.push(snapshot[\"address-level1\"] || \"\");\n  searchText.push(snapshot[\"postal-code\"] || \"\");\n  if (snapshot[\"country-name\"]) {\n    searchText.push(snapshot[\"country-name\"]);\n  } else {\n    searchText.push(snapshot[\"country\"] || \"\");\n  }\n  return searchText.filter((part) => Boolean(part)).join(\", \");\n}\nfunction fillFormWithFeature(feature, input) {\n  const form = findParentForm(input);\n  if (!form) {\n    return;\n  }\n  const suggestion = featureToSuggestion(feature);\n  setFormAutofillValues(form, input, suggestion);\n  const inputMap = findAddressAutofillInputs(form, input);\n  if (inputMap[\"address-line2\"]) {\n    inputMap[\"address-line2\"].focus();\n  }\n}\nfunction featureToAutofillValueMap(feature) {\n  var _a;\n  const values = {};\n  const streetAddress = [\n    feature.properties.address_line1,\n    feature.properties.address_line2,\n    feature.properties.address_line3\n  ].filter((part) => Boolean(part)).join(\", \");\n  values[\"street-address\"] = streetAddress;\n  values[\"address-line1\"] = feature.properties.address_line1;\n  values[\"address-line2\"] = feature.properties.address_line2;\n  values[\"address-line3\"] = feature.properties.address_line3;\n  values[\"address-level1\"] = feature.properties.address_level1;\n  values[\"address-level2\"] = feature.properties.address_level2;\n  values[\"address-level3\"] = feature.properties.address_level3;\n  values[\"country\"] = (_a = feature.properties.metadata) == null ? void 0 : _a.iso_3166_1;\n  values[\"country-name\"] = feature.properties.country;\n  values[\"postal-code\"] = feature.properties.postcode;\n  return values;\n}\nfunction checkAutofillValuesChanged(targetMap, referenceMap) {\n  for (const [key, value] of Object.entries(targetMap)) {\n    if (referenceMap[key] !== value)\n      return true;\n  }\n  return false;\n}\nvar distinctExactStreetResults = (suggestions) => {\n  return suggestions.filter((item1, idx, arr) => {\n    const title = getSuggestionTitle(item1, 0 /* AddressAutofill */);\n    return item1.accuracy !== \"street\" || arr.findIndex((item2) => title === getSuggestionTitle(item2, 0 /* AddressAutofill */)) === idx;\n  });\n};\nvar toggleAutocompletion = (input, initialAutocompleteValue, enableBrowserAutocomplete) => {\n  const disableValue = \"new-password\";\n  const defaultFallbackValue = \"address-line1\";\n  const autocompleteValue = enableBrowserAutocomplete ? initialAutocompleteValue || defaultFallbackValue : disableValue;\n  if (input) {\n    input.autocomplete = autocompleteValue;\n  }\n};\nvar handleStreetSelection = (input, initialAutocompleteValue, suggestion) => {\n  if (!input || !suggestion) {\n    return;\n  }\n  toggleAutocompletion(input, initialAutocompleteValue, true);\n  const feature = {\n    properties: __spreadProps(__spreadValues({}, suggestion), {\n      address_line1: suggestion.address_line1 + \" \",\n      postcode: null\n    })\n  };\n  fillFormWithFeature(feature, input);\n  toggleAutocompletion(input, initialAutocompleteValue, false);\n  input == null ? void 0 : input.focus();\n};\n\n// src/confirmAddress.ts\nimport {\n  featureToSuggestion as featureToSuggestion2\n} from \"@mapbox/search-js-core\";\n\n// src/components/MapboxAddressConfirmation.ts\nimport {\n  MatchCodeConfidence,\n  ValidationCore\n} from \"@mapbox/search-js-core\";\nimport noScroll from \"no-scroll\";\nimport { createFocusTrap } from \"focus-trap\";\n\n// src/config.ts\nimport { SessionToken as SessionToken2 } from \"@mapbox/search-js-core\";\nvar Config = class {\n  constructor() {\n    this.feedbackEnabled = true;\n    this.autofillSessionToken = new SessionToken2();\n    this.autofillSessionEnabled = false;\n    this.detectBrowserAutofillEnabled = false;\n  }\n};\nvar config = new Config();\nObject.defineProperty(config, \"autofillSessionToken\", {\n  configurable: false,\n  writable: false\n});\n\n// src/components/MapboxAddressConfirmation.ts\nvar TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmation\" aria-hidden=\"true\">\n    <mapbox-address-confirmation-feature class=\"ContentFeature\"></mapbox-address-confirmation-feature>\n    <mapbox-address-confirmation-no-feature class=\"ContentNoFeature\"></mapbox-address-confirmation-no-feature>\n  </div>\n</template>\n`);\nvar _show, _binding2, _focusTrap, _themeInternal2;\nvar MapboxAddressConfirmation = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _show, false);\n    __privateAdd(this, _binding2, void 0);\n    __privateAdd(this, _focusTrap, void 0);\n    __privateAdd(this, _themeInternal2, {});\n  }\n  get template() {\n    return TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmation\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal2);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal2, theme);\n    if (!__privateGet(this, _binding2) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmation\", theme));\n    const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n    ContentFeature.theme = theme;\n    ContentNoFeature.theme = theme;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding2, bindElements(this, {\n      MapboxAddressConfirmation: \".MapboxAddressConfirmation\",\n      ContentFeature: \".ContentFeature\",\n      ContentNoFeature: \".ContentNoFeature\"\n    }));\n    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);\n    MapboxAddressConfirmation2.setAttribute(\"aria-hidden\", \"true\");\n    const theme = this.theme;\n    if (theme) {\n      const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n      ContentFeature.theme = theme;\n      ContentNoFeature.theme = theme;\n    }\n  }\n  disconnectedCallback() {\n    __privateSet(this, _focusTrap, null);\n  }\n  hide() {\n    var _a;\n    __privateSet(this, _show, false);\n    if (!__privateGet(this, _binding2)) {\n      return;\n    }\n    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);\n    MapboxAddressConfirmation2.setAttribute(\"aria-hidden\", \"true\");\n    (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.deactivate();\n    noScroll.off();\n  }\n  show(autofillValues, optionsArg, feature) {\n    return __async(this, null, function* () {\n      var _a;\n      if (!__privateGet(this, _binding2)) {\n        return { type: \"cancel\" };\n      }\n      const { MapboxAddressConfirmation: MapboxAddressConfirmation2, ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n      const { accessToken, minimap = false, theme, footer } = optionsArg;\n      this.theme = theme;\n      if (feature) {\n        ContentFeature.removeAttribute(\"aria-hidden\");\n        ContentNoFeature.setAttribute(\"aria-hidden\", \"true\");\n        ContentFeature.minimap = minimap;\n        ContentFeature.accessToken = accessToken;\n        ContentFeature.footer = footer;\n        ContentFeature.update(feature, autofillValues);\n      } else {\n        ContentFeature.setAttribute(\"aria-hidden\", \"true\");\n        ContentNoFeature.removeAttribute(\"aria-hidden\");\n        ContentNoFeature.update(autofillValues);\n      }\n      __privateSet(this, _show, true);\n      MapboxAddressConfirmation2.removeAttribute(\"aria-hidden\");\n      noScroll.on();\n      const activeContentElement = feature ? ContentFeature : ContentNoFeature;\n      __privateSet(this, _focusTrap, createFocusTrap(MapboxAddressConfirmation2, {\n        fallbackFocus: activeContentElement,\n        escapeDeactivates: () => {\n          this.hide();\n          return true;\n        }\n      }));\n      (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.activate();\n      return new Promise((resolve) => {\n        const eventHost = activeContentElement;\n        const fn = (e) => {\n          eventHost.removeEventListener(\"result\", fn);\n          const result = e.detail;\n          this.hide();\n          if (result === \"change\") {\n            resolve({\n              type: \"change\",\n              feature\n            });\n          } else {\n            resolve({\n              type: result\n            });\n          }\n        };\n        eventHost.addEventListener(\"result\", fn);\n      });\n    });\n  }\n  tryShow(autofillValues, optionsArg) {\n    return __async(this, null, function* () {\n      if (!__privateGet(this, _binding2)) {\n        return { type: \"cancel\" };\n      }\n      const { accessToken, options = {} } = optionsArg;\n      const validate = new ValidationCore(__spreadValues({\n        accessToken\n      }, options));\n      const searchText = getAutofillSearchText(autofillValues);\n      const featureCollection = yield validate.validate(searchText, {\n        sessionToken: config.autofillSessionToken\n      });\n      const feature = featureCollection.features[0];\n      if (feature) {\n        const defaultValidation = (feature2) => feature2.properties.match_code.confidence === MatchCodeConfidence.exact;\n        const { skipConfirmModal = defaultValidation } = optionsArg;\n        if (skipConfirmModal(feature)) {\n          return { type: \"nochange\" };\n        }\n      }\n      return yield this.show(autofillValues, optionsArg, feature);\n    });\n  }\n};\n_show = new WeakMap();\n_binding2 = new WeakMap();\n_focusTrap = new WeakMap();\n_themeInternal2 = new WeakMap();\nwindow.MapboxAddressConfirmation = MapboxAddressConfirmation;\nif (!window.customElements.get(\"mapbox-address-confirmation\")) {\n  customElements.define(\"mapbox-address-confirmation\", MapboxAddressConfirmation);\n}\n\n// src/confirmAddress.ts\nvar confirmation = new MapboxAddressConfirmation();\nfunction confirmAddress(_0) {\n  return __async(this, arguments, function* (form, optionsArg = {}) {\n    const { sections = [] } = optionsArg;\n    if (!confirmation.parentNode) {\n      document.body.appendChild(confirmation);\n    }\n    let collectedResult = { type: \"nochange\" };\n    const inputs = findAddressInputs(form);\n    const structure = parseFormStructure(form);\n    const listboxComponents = Array.from(document.querySelectorAll(\"mapbox-search-listbox\"));\n    for (const input of inputs) {\n      if (sections.length) {\n        const structureRef = structure.find((s) => s.input === input);\n        if (!structureRef) {\n          continue;\n        }\n        if (!sections.includes(structureRef.section)) {\n          continue;\n        }\n      }\n      const autofillValues = getFormAutofillValues(form, input);\n      const listbox = listboxComponents.find((lb) => lb.input === input);\n      const autofill2 = listbox == null ? void 0 : listbox.autofillHost;\n      if (autofill2) {\n        const lastRetrievedFeature = autofill2.retrieveFeature;\n        if (lastRetrievedFeature) {\n          const snapshot = featureToAutofillValueMap(lastRetrievedFeature);\n          if (!checkAutofillValuesChanged(autofillValues, snapshot)) {\n            continue;\n          }\n        }\n      }\n      const accessToken = optionsArg.accessToken || config.accessToken;\n      const result = yield confirmation.tryShow(autofillValues, __spreadProps(__spreadValues({}, optionsArg), {\n        accessToken\n      }));\n      if (result.type === \"change\") {\n        if (listbox) {\n          autofill2.simulateRetrieve(result.feature);\n        } else {\n          input.dataset[\"mapboxSuccess\"] = \"true\";\n          const suggestion = featureToSuggestion2(result.feature);\n          setFormAutofillValues(form, input, suggestion);\n        }\n      }\n      if (result.type === \"change\" && collectedResult.type !== \"cancel\") {\n        collectedResult = result;\n      }\n      if (result.type === \"cancel\") {\n        collectedResult = result;\n      }\n    }\n    return collectedResult;\n  });\n}\n\n// src/utils/confirmation.ts\nfunction createAddressElement(autofillValues, baseAddress) {\n  if (baseAddress) {\n    const element = createElementFromString(`\n        <span>\n          <span></span>\n          <br />\n          <span></span>\n        </span>\n      `);\n    const [firstLine, lastLine] = Array.from(element.querySelectorAll(\"span > span\"));\n    const parts = baseAddress.split(\",\");\n    firstLine.textContent = parts[0].trim();\n    lastLine.textContent = parts.slice(1).join(\",\").trim();\n    if (autofillValues[\"address-line2\"]) {\n      const span = document.createElement(\"span\");\n      span.textContent = autofillValues[\"address-line2\"];\n      element.insertBefore(span, lastLine);\n      element.insertBefore(document.createElement(\"br\"), lastLine);\n    }\n    if (autofillValues[\"address-line3\"]) {\n      const span = document.createElement(\"span\");\n      span.textContent = autofillValues[\"address-line3\"];\n      element.insertBefore(span, lastLine);\n      element.insertBefore(document.createElement(\"br\"), lastLine);\n    }\n    return element;\n  } else {\n    const firstLine = autofillValues[\"street-address\"] || autofillValues[\"address-line1\"] || \"\";\n    const line2 = autofillValues[\"address-line2\"];\n    const line3 = autofillValues[\"address-line3\"];\n    const lastLine = [\n      autofillValues[\"address-level4\"] || \"\",\n      autofillValues[\"address-level3\"] || \"\",\n      autofillValues[\"address-level2\"] || \"\",\n      `${autofillValues[\"address-level1\"] || \"\"} ${autofillValues[\"postal-code\"] || \"\"}`,\n      autofillValues.country || autofillValues[\"country-name\"] || \"\"\n    ].filter(Boolean).join(\", \");\n    const addressLines = [firstLine, line2, line3, lastLine].filter(Boolean);\n    const addressLinesHtml = addressLines.map((val) => `<span>${val}</span>`).join(\"<br />\");\n    const element = createElementFromString(`\n        <span>${addressLinesHtml}</span>\n      `);\n    return element;\n  }\n}\nfunction tryConfirmBrowserAutofill(input, event, confirmOnBrowserAutofill, accessToken) {\n  return __async(this, null, function* () {\n    if (!confirmOnBrowserAutofill)\n      return;\n    const parentForm = findParentForm(input);\n    const formElements = Object.values(findAddressAutofillInputs(parentForm, input));\n    if (!event.detail.elements.some((el) => formElements.includes(el))) {\n      return;\n    }\n    const structure = parseFormStructure(parentForm);\n    const structureRef = structure.find((s) => s.input === input);\n    const autofillInstanceSection = structureRef.section;\n    const browserAutofilledSections = Array.from(new Set(structure.filter((s) => event.detail.elements.includes(s.input)).map((s) => s.section)));\n    if (!browserAutofilledSections.includes(autofillInstanceSection)) {\n      return;\n    }\n    const optionsSections = typeof confirmOnBrowserAutofill === \"object\" && confirmOnBrowserAutofill.sections || [];\n    if (optionsSections.length && !optionsSections.some((section) => browserAutofilledSections.includes(section))) {\n      return;\n    }\n    let optionsArg = typeof confirmOnBrowserAutofill === \"object\" ? confirmOnBrowserAutofill : {};\n    optionsArg = __spreadProps(__spreadValues({}, optionsArg), {\n      accessToken,\n      sections: [autofillInstanceSection]\n    });\n    yield confirmAddress(parentForm, optionsArg);\n  });\n}\n\n// src/utils/contribute.ts\nvar CONTRIBUTE_API_BASE_URL = \"https://contribute-api.mapbox.com/v1\";\nvar CONTRIBUTE_API_STAGING_BASE_URL = \"https://contribute-api-staging.tilestream.net/v1\";\nvar EDIT_SUGGESTION_ENDPOINT = \"edit-suggestion\";\nfunction sendFeedback(accessToken, feedbackArgs) {\n  if (!config.feedbackEnabled)\n    return;\n  const hostname = window.location.hostname;\n  const BASE_URL = isLocalServer(hostname) || isMapboxDomain(hostname) ? CONTRIBUTE_API_STAGING_BASE_URL : CONTRIBUTE_API_BASE_URL;\n  const url = `${BASE_URL}/${EDIT_SUGGESTION_ENDPOINT}/address?access_token=${accessToken}`;\n  const { originalCoordinate, originalAddress, changes } = feedbackArgs;\n  const payload = {\n    action: \"update\",\n    reason: \"incorrect_address\",\n    location: {\n      longitude: originalCoordinate[0],\n      latitude: originalCoordinate[1]\n    },\n    userEmail: \"no-reply-autofill@mapbox.com\",\n    changes,\n    placeName: originalAddress\n  };\n  fetch(url, {\n    method: \"POST\",\n    headers: new Headers({\n      \"User-Agent\": `mapbox-search-js.${version}.${navigator.userAgent}`,\n      \"Content-Type\": \"application/json\"\n    }),\n    body: JSON.stringify(payload)\n  });\n}\n\n// src/components/MapboxAddressConfirmationFeature.ts\nvar TEMPLATE2 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmationFeature\">\n    <div class=\"Modal\" aria-modal=\"true\" role=\"dialog\">\n      <div class=\"ModalHeader\">\n        <svg viewBox=\"0 0 18 18\" class=\"Icon IconQuestion\"></svg>\n        <div class=\"ModalHeaderTitle\">Did you mean?</div>\n        <svg\n          viewBox=\"0 0 18 18\"\n          class=\"Icon IconClose\"\n          tabindex=\"0\"\n          role=\"button\"\n          title=\"Close\"\n          aria-label=\"Close\"\n          aria-expanded=\"true\"\n        ></svg>\n      </div>\n\n      <div class=\"ModalAddress ModalAddressApprove\"></div>\n            \n      <div class=\"ModalMap\">\n        <mapbox-address-minimap class=\"Minimap\"></mapbox-address-minimap>\n      </div>\n\n      <div\n        class=\"Button ButtonPrimary ButtonApprove\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Yes\"\n      >\n        Yes\n      </div>\n      \n      <div\n        class=\"Button ButtonSecondary ButtonReject\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"No, use the address I provided\"\n      >\n        No, use the address I provided\n      </div>\n\n      <div class=\"ModalFooter\">\n          Your confirmation helps improve address data accuracy.\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar _binding3, _themeInternal3, _feature, _formValues, _handleClose, _modalID, _modalHeaderTitleID, _modalAddressApproveID;\nvar MapboxAddressConfirmationFeature = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _binding3, void 0);\n    __privateAdd(this, _themeInternal3, {});\n    this.minimap = false;\n    __privateAdd(this, _feature, void 0);\n    __privateAdd(this, _formValues, void 0);\n    this.update = (feature, autofillValues) => {\n      __privateSet(this, _feature, feature);\n      __privateSet(this, _formValues, autofillValues);\n      const { ModalMap, Minimap, ModalAddressApprove } = __privateGet(this, _binding3);\n      if (this.minimap) {\n        ModalMap.removeAttribute(\"aria-hidden\");\n        Minimap.accessToken = this.accessToken;\n        if (typeof this.minimap === \"object\") {\n          const { defaultMapStyle, theme, mapStyleMode, satelliteToggle } = this.minimap;\n          defaultMapStyle && (Minimap.defaultMapStyle = this.minimap.defaultMapStyle);\n          theme && (Minimap.theme = this.minimap.theme);\n          mapStyleMode && (Minimap.mapStyleMode = mapStyleMode);\n          satelliteToggle !== void 0 && (Minimap.satelliteToggle = satelliteToggle);\n        }\n        Minimap.feature = feature;\n      } else {\n        ModalMap.setAttribute(\"aria-hidden\", \"true\");\n      }\n      const approveAddress = feature.properties.place_name || feature.properties.full_address || feature.properties.address;\n      ModalAddressApprove.innerHTML = \"\";\n      ModalAddressApprove.appendChild(createAddressElement(autofillValues, approveAddress));\n    };\n    __privateAdd(this, _handleClose, () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"cancel\"));\n    });\n    this.approve = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"change\"));\n    };\n    this.reject = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"nochange\"));\n      sendFeedback(this.accessToken, {\n        originalCoordinate: __privateGet(this, _feature).geometry.coordinates,\n        originalAddress: __privateGet(this, _feature).properties.full_address,\n        changes: {\n          address: getAutofillSearchText(__privateGet(this, _formValues))\n        }\n      });\n    };\n    __privateAdd(this, _modalID, randomValidID());\n    __privateAdd(this, _modalHeaderTitleID, randomValidID());\n    __privateAdd(this, _modalAddressApproveID, randomValidID());\n  }\n  get template() {\n    return TEMPLATE2;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmationFeature\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal3);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal3, theme);\n    if (!__privateGet(this, _binding3) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmationFeature\", theme));\n    const { IconQuestion, IconClose } = __privateGet(this, _binding3);\n    IconQuestion.innerHTML = getIcon(\"question\", theme);\n    IconClose.innerHTML = getIcon(\"close\", theme);\n  }\n  set footer(val) {\n    if (val === void 0)\n      return;\n    const footerEl = this.querySelector(\".ModalFooter\");\n    if (typeof val === \"string\") {\n      footerEl.textContent = val;\n      footerEl.removeAttribute(\"aria-hidden\");\n    } else if (!val) {\n      footerEl.setAttribute(\"aria-hidden\", \"true\");\n    } else {\n      footerEl.removeAttribute(\"aria-hidden\");\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding3, bindElements(this, {\n      MapboxAddressConfirmationFeature: \".MapboxAddressConfirmationFeature\",\n      Modal: \".Modal\",\n      ModalHeaderTitle: \".ModalHeaderTitle\",\n      ModalMap: \".ModalMap\",\n      Minimap: \".Minimap\",\n      IconQuestion: \".IconQuestion\",\n      IconClose: \".IconClose\",\n      ButtonApprove: \".ButtonApprove\",\n      ButtonReject: \".ButtonReject\",\n      ModalAddressApprove: \".ModalAddressApprove\"\n    }));\n    const {\n      Modal,\n      ModalHeaderTitle,\n      IconClose,\n      ButtonApprove,\n      ButtonReject,\n      ModalAddressApprove\n    } = __privateGet(this, _binding3);\n    Modal.setAttribute(\"aria-labelledby\", __privateGet(this, _modalHeaderTitleID));\n    Modal.setAttribute(\"aria-describedby\", __privateGet(this, _modalAddressApproveID));\n    IconClose.setAttribute(\"aria-controls\", __privateGet(this, _modalID));\n    Modal.id = __privateGet(this, _modalID);\n    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID);\n    ModalAddressApprove.id = __privateGet(this, _modalAddressApproveID);\n    const buttons = Array.from(this.querySelectorAll('[role=\"button\"]'));\n    for (const button of buttons) {\n      button.addEventListener(\"keydown\", ariaButtonKeyDown);\n    }\n    IconClose.addEventListener(\"click\", __privateGet(this, _handleClose));\n    ButtonApprove.addEventListener(\"click\", this.approve);\n    ButtonReject.addEventListener(\"click\", this.reject);\n    const theme = this.theme;\n    if (theme) {\n      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding3);\n      IconQuestion.innerHTML = getIcon(\"question\", theme);\n      IconClose2.innerHTML = getIcon(\"close\", theme);\n    }\n  }\n  disconnectedCallback() {\n    const { IconClose, ButtonApprove } = __privateGet(this, _binding3);\n    IconClose.removeEventListener(\"click\", __privateGet(this, _handleClose));\n    ButtonApprove.removeEventListener(\"click\", this.approve);\n  }\n};\n_binding3 = new WeakMap();\n_themeInternal3 = new WeakMap();\n_feature = new WeakMap();\n_formValues = new WeakMap();\n_handleClose = new WeakMap();\n_modalID = new WeakMap();\n_modalHeaderTitleID = new WeakMap();\n_modalAddressApproveID = new WeakMap();\nwindow.MapboxAddressConfirmationFeature = MapboxAddressConfirmationFeature;\nif (!window.customElements.get(\"mapbox-address-confirmation-feature\")) {\n  customElements.define(\"mapbox-address-confirmation-feature\", MapboxAddressConfirmationFeature);\n}\n\n// src/components/MapboxAddressConfirmationNoFeature.ts\nvar TEMPLATE3 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmationNoFeature\">\n    <div class=\"Modal\" aria-modal=\"true\" role=\"dialog\">\n      <div class=\"ModalHeader\">\n        <svg viewBox=\"0 0 18 18\" class=\"Icon IconQuestion\"></svg>\n        <div class=\"ModalHeaderTitle\">Confirm address</div>\n        <svg\n          viewBox=\"0 0 18 18\"\n          class=\"Icon IconClose\"\n          tabindex=\"0\"\n          role=\"button\"\n          title=\"Close\"\n          aria-label=\"Close\"\n          aria-expanded=\"true\"\n        ></svg>\n      </div>\n      <div class=\"ModalDescription\">\n        We couldn't verify this address. Please check that your information is correct before continuing.\n      </div>\n      <br />\n      <div class=\"ModalSubheader\">\n        You entered\n      </div>\n      <div class=\"ModalAddress\"></div>\n      <div\n        class=\"Button ButtonPrimary\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Use the address I provided\"\n      >\n        Use the address I provided\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar _binding4, _themeInternal4, _handleClose2, _modalID2, _modalHeaderTitleID2, _modalAddressID;\nvar MapboxAddressConfirmationNoFeature = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _binding4, void 0);\n    __privateAdd(this, _themeInternal4, {});\n    this.update = (autofillValues) => {\n      const { ModalAddress } = __privateGet(this, _binding4);\n      ModalAddress.innerHTML = \"\";\n      ModalAddress.appendChild(createAddressElement(autofillValues));\n    };\n    __privateAdd(this, _handleClose2, () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"cancel\"));\n    });\n    this.reject = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"nochange\"));\n    };\n    __privateAdd(this, _modalID2, randomValidID());\n    __privateAdd(this, _modalHeaderTitleID2, randomValidID());\n    __privateAdd(this, _modalAddressID, randomValidID());\n  }\n  get template() {\n    return TEMPLATE3;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmationNoFeature\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal4);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal4, theme);\n    if (!__privateGet(this, _binding4) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmationNoFeature\", theme));\n    const { IconQuestion, IconClose } = __privateGet(this, _binding4);\n    IconQuestion.innerHTML = getIcon(\"question\", theme);\n    IconClose.innerHTML = getIcon(\"close\", theme);\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding4, bindElements(this, {\n      Modal: \".Modal\",\n      ModalHeaderTitle: \".ModalHeaderTitle\",\n      IconQuestion: \".IconQuestion\",\n      IconClose: \".IconClose\",\n      ModalAddress: \".ModalAddress\",\n      ButtonReject: \".Button\"\n    }));\n    const { Modal, ModalHeaderTitle, IconClose, ModalAddress, ButtonReject } = __privateGet(this, _binding4);\n    Modal.setAttribute(\"aria-labelledby\", __privateGet(this, _modalHeaderTitleID2));\n    Modal.setAttribute(\"aria-describedby\", __privateGet(this, _modalAddressID));\n    IconClose.setAttribute(\"aria-controls\", __privateGet(this, _modalID2));\n    Modal.id = __privateGet(this, _modalID2);\n    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID2);\n    ModalAddress.id = __privateGet(this, _modalAddressID);\n    const buttons = Array.from(this.querySelectorAll('[role=\"button\"]'));\n    for (const button of buttons) {\n      button.addEventListener(\"keydown\", ariaButtonKeyDown);\n    }\n    IconClose.addEventListener(\"click\", __privateGet(this, _handleClose2));\n    ButtonReject.addEventListener(\"click\", this.reject);\n    const theme = this.theme;\n    if (theme) {\n      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding4);\n      IconQuestion.innerHTML = getIcon(\"question\", theme);\n      IconClose2.innerHTML = getIcon(\"close\", theme);\n    }\n  }\n  disconnectedCallback() {\n    const { IconClose, ButtonReject } = __privateGet(this, _binding4);\n    IconClose.removeEventListener(\"click\", __privateGet(this, _handleClose2));\n    ButtonReject.removeEventListener(\"click\", this.reject);\n  }\n};\n_binding4 = new WeakMap();\n_themeInternal4 = new WeakMap();\n_handleClose2 = new WeakMap();\n_modalID2 = new WeakMap();\n_modalHeaderTitleID2 = new WeakMap();\n_modalAddressID = new WeakMap();\nwindow.MapboxAddressConfirmationNoFeature = MapboxAddressConfirmationNoFeature;\nif (!window.customElements.get(\"mapbox-address-confirmation-no-feature\")) {\n  customElements.define(\"mapbox-address-confirmation-no-feature\", MapboxAddressConfirmationNoFeature);\n}\n\n// src/components/MapboxAddressAutofill.ts\nimport {\n  AddressAutofillCore,\n  SearchSession\n} from \"@mapbox/search-js-core\";\n\n// src/utils/detect_browser_autofill.ts\nimport { debounce } from \"@mapbox/search-js-core\";\n\n// src/utils/detect_browser_autofill.css\nvar detect_browser_autofill_default = 'input:-webkit-autofill,select:-webkit-autofill,textarea:-webkit-autofill{animation-name:onbrowserautofillstart}input:not(:-webkit-autofill),select:not(:-webkit-autofill),textarea:not(:-webkit-autofill){animation-name:onbrowserautofillcancel}@keyframes onbrowserautofillstart{0%{animation-name:\"onbrowserautofillstart\"}to{animation-name:\"onbrowserautofillstart\"}}@keyframes onbrowserautofillcancel{0%{animation-name:\"onbrowserautofillcancel\"}to{animation-name:\"onbrowserautofillcancel\"}}';\n\n// src/utils/detect_browser_autofill.ts\nvar ATTR_NAME = \"browser-autofilled\";\nvar AUTOFILLED_ELEMENTS = [];\nfunction dispatchBrowserAutofillEvent() {\n  window.dispatchEvent(new window.CustomEvent(\"browserautofill\", {\n    bubbles: true,\n    cancelable: true,\n    detail: { elements: AUTOFILLED_ELEMENTS }\n  }));\n  AUTOFILLED_ELEMENTS = [];\n}\nvar debouncedAutofill = debounce(dispatchBrowserAutofillEvent, 5);\nfunction browserAutofill(element) {\n  if (element.hasAttribute(ATTR_NAME))\n    return;\n  element.setAttribute(ATTR_NAME, \"\");\n  AUTOFILLED_ELEMENTS.push(element);\n  debouncedAutofill();\n}\nfunction cancelBrowserAutofill(element) {\n  if (!element.hasAttribute(ATTR_NAME))\n    return;\n  element.removeAttribute(ATTR_NAME);\n}\nfunction onAnimationStart(event) {\n  event.animationName === \"onbrowserautofillstart\" ? browserAutofill(event.target) : cancelBrowserAutofill(event.target);\n}\nfunction onInput(event) {\n  const targetEl = event.target;\n  targetEl.nodeName.toLowerCase() !== \"select\" && !event.simulated && !(event instanceof MapboxHTMLEvent) && (event.inputType === \"insertReplacementText\" || !(\"data\" in event)) ? browserAutofill(targetEl) : cancelBrowserAutofill(targetEl);\n}\nfunction initDetectBrowserAutofill() {\n  if (config.detectBrowserAutofillEnabled) {\n    return;\n  } else {\n    config.detectBrowserAutofillEnabled = true;\n  }\n  addDocumentStyle(detect_browser_autofill_default);\n  document.addEventListener(\"animationstart\", onAnimationStart, true);\n  document.addEventListener(\"input\", onInput, true);\n}\n\n// src/components/MapboxAddressAutofill.ts\nvar _autofill, _session, _input, _listbox, _initialAutocompleteValue, _browserAutofillEnabled, _handleSuggest, _handleSuggestError, _handleRetrieve, _handleObserve, _observer, _handleBrowserAutofill, _onHandleInput, _onHandleSelect, _onHandleBlur, _onHandleFocus;\nvar MapboxAddressAutofill = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _autofill, new AddressAutofillCore());\n    __privateAdd(this, _session, new SearchSession(__privateGet(this, _autofill)));\n    __privateAdd(this, _input, void 0);\n    __privateAdd(this, _listbox, new MapboxSearchListbox());\n    __privateAdd(this, _initialAutocompleteValue, void 0);\n    this.options = {};\n    this.confirmOnBrowserAutofill = false;\n    __privateAdd(this, _browserAutofillEnabled, false);\n    __privateAdd(this, _handleSuggest, (result) => {\n      const filteredSuggestions = (result == null ? void 0 : result.suggestions) ? distinctExactStreetResults(result.suggestions) : null;\n      __privateGet(this, _listbox).handleSuggest(filteredSuggestions);\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggest\", result));\n    });\n    __privateAdd(this, _handleSuggestError, (error) => {\n      __privateGet(this, _listbox).handleError();\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggesterror\", error));\n    });\n    __privateAdd(this, _handleRetrieve, (result) => {\n      var _a;\n      this.dispatchEvent(new MapboxHTMLEvent(\"retrieve\", result));\n      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];\n      if (!__privateGet(this, _input)) {\n        return;\n      }\n      const featureCollection = result;\n      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {\n        return;\n      }\n      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input));\n    });\n    __privateAdd(this, _handleObserve, () => {\n      var _a;\n      try {\n        const input = (_a = this.querySelector(\"input\")) != null ? _a : null;\n        __privateSet(this, _input, input);\n        __privateGet(this, _listbox).input = input;\n      } catch (e) {\n        __privateSet(this, _input, null);\n        __privateGet(this, _listbox).input = null;\n        console.error(e.message || e);\n      }\n    });\n    __privateAdd(this, _observer, new MutationObserver(__privateGet(this, _handleObserve)));\n    __privateAdd(this, _handleBrowserAutofill, (e) => {\n      __privateGet(this, _listbox).blur();\n      tryConfirmBrowserAutofill(__privateGet(this, _input), e, this.confirmOnBrowserAutofill, this.accessToken);\n    });\n    this.retrieveFeature = null;\n    this.interceptSearch = null;\n    __privateAdd(this, _onHandleInput, (e) => {\n      this.dispatchEvent(e.clone());\n      const inputText = e.detail;\n      const enableBrowserAutocomplete = this.browserAutofillEnabled === true && (inputText == null ? void 0 : inputText.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), enableBrowserAutocomplete);\n      const alteredText = this.interceptSearch && this.interceptSearch(inputText);\n      const searchText = this.interceptSearch ? alteredText : inputText;\n      if (this.interceptSearch && !alteredText || (searchText == null ? void 0 : searchText.length) <= 2) {\n        __privateGet(this, _listbox).handleSuggest(null);\n        return;\n      }\n      __privateGet(this, _session).suggest(searchText, this.options);\n    });\n    __privateAdd(this, _onHandleSelect, (e) => {\n      const suggestion = e.detail;\n      if (e.detail.accuracy !== \"street\") {\n        toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), true);\n        __privateGet(this, _session).retrieve(suggestion, this.options);\n      } else {\n        handleStreetSelection(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), suggestion);\n      }\n    });\n    __privateAdd(this, _onHandleBlur, () => {\n      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), true);\n      __privateGet(this, _session).abort();\n    });\n    __privateAdd(this, _onHandleFocus, () => {\n      var _a;\n      const enableBrowserAutocomplete = this.browserAutofillEnabled === true && ((_a = __privateGet(this, _input).value) == null ? void 0 : _a.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), enableBrowserAutocomplete);\n    });\n  }\n  get accessToken() {\n    return __privateGet(this, _autofill).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _autofill).accessToken = newToken;\n  }\n  get input() {\n    return __privateGet(this, _input);\n  }\n  get theme() {\n    return __privateGet(this, _listbox).theme;\n  }\n  set theme(theme) {\n    __privateGet(this, _listbox).theme = theme;\n  }\n  get popoverOptions() {\n    return __privateGet(this, _listbox).popoverOptions;\n  }\n  set popoverOptions(newOptions) {\n    __privateGet(this, _listbox).popoverOptions = newOptions;\n  }\n  get browserAutofillEnabled() {\n    return __privateGet(this, _browserAutofillEnabled);\n  }\n  set browserAutofillEnabled(enable) {\n    __privateSet(this, _browserAutofillEnabled, enable);\n  }\n  connectedCallback() {\n    var _a;\n    super.connectedCallback();\n    config.autofillSessionEnabled = true;\n    __privateGet(this, _session).sessionToken = config.autofillSessionToken;\n    __privateGet(this, _listbox).autofillHost = this;\n    __privateGet(this, _listbox).searchService = 0 /* AddressAutofill */;\n    const input = (_a = this.querySelector(\"input\")) != null ? _a : null;\n    __privateGet(this, _observer).observe(this, {\n      subtree: true,\n      childList: true\n    });\n    __privateGet(this, _handleObserve).call(this);\n    __privateGet(this, _listbox).addEventListener(\"input\", __privateGet(this, _onHandleInput));\n    __privateGet(this, _listbox).addEventListener(\"select\", __privateGet(this, _onHandleSelect));\n    __privateGet(this, _listbox).addEventListener(\"blur\", __privateGet(this, _onHandleBlur));\n    __privateGet(this, _listbox).addEventListener(\"focus\", __privateGet(this, _onHandleFocus));\n    __privateGet(this, _session).addEventListener(\"suggest\", __privateGet(this, _handleSuggest));\n    __privateGet(this, _session).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError));\n    __privateGet(this, _session).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve));\n    document.body.appendChild(__privateGet(this, _listbox));\n    if (input) {\n      input.insertAdjacentElement(\"beforebegin\", createAriaLiveElement(__privateGet(this, _listbox).dataSeed));\n      suppressExtensionsAutocomplete(input);\n      __privateSet(this, _initialAutocompleteValue, input.autocomplete);\n    }\n    initDetectBrowserAutofill();\n    window.addEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill));\n  }\n  disconnectedCallback() {\n    __privateGet(this, _listbox).remove();\n    __privateGet(this, _listbox).removeEventListener(\"input\", __privateGet(this, _onHandleInput));\n    __privateGet(this, _listbox).removeEventListener(\"select\", __privateGet(this, _onHandleSelect));\n    __privateGet(this, _listbox).removeEventListener(\"blur\", __privateGet(this, _onHandleBlur));\n    __privateGet(this, _listbox).removeEventListener(\"focus\", __privateGet(this, _onHandleFocus));\n    __privateGet(this, _session).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest));\n    __privateGet(this, _session).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError));\n    __privateGet(this, _session).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve));\n    __privateGet(this, _observer).disconnect();\n    window.removeEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill));\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      __privateGet(this, _autofill).accessToken = newValue;\n      return;\n    }\n    if (name === \"browser-autofill-enabled\") {\n      __privateSet(this, _browserAutofillEnabled, Boolean(newValue));\n      return;\n    }\n    if (name === \"theme\") {\n      this.theme = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"popover-options\") {\n      this.popoverOptions = tryParseJSON(newValue);\n      return;\n    }\n    const optionName = name.split(\"-\").join(\"_\");\n    if (!newValue) {\n      delete this.options[optionName];\n    }\n    this.options[optionName] = newValue;\n  }\n  focus() {\n    __privateGet(this, _listbox).focus();\n  }\n  simulateRetrieve(feature) {\n    const input = this.input;\n    if (input) {\n      input.dataset[\"mapboxSuccess\"] = \"true\";\n    }\n    __privateGet(this, _listbox).hideResults();\n    const simResult = {\n      type: \"FeatureCollection\",\n      features: [feature],\n      url: \"\"\n    };\n    __privateGet(this, _handleRetrieve).call(this, simResult);\n  }\n};\n_autofill = new WeakMap();\n_session = new WeakMap();\n_input = new WeakMap();\n_listbox = new WeakMap();\n_initialAutocompleteValue = new WeakMap();\n_browserAutofillEnabled = new WeakMap();\n_handleSuggest = new WeakMap();\n_handleSuggestError = new WeakMap();\n_handleRetrieve = new WeakMap();\n_handleObserve = new WeakMap();\n_observer = new WeakMap();\n_handleBrowserAutofill = new WeakMap();\n_onHandleInput = new WeakMap();\n_onHandleSelect = new WeakMap();\n_onHandleBlur = new WeakMap();\n_onHandleFocus = new WeakMap();\nMapboxAddressAutofill.observedAttributes = [\n  \"access-token\",\n  \"browser-autofill-enabled\",\n  \"theme\",\n  \"popover-options\",\n  \"css-text\",\n  \"language\",\n  \"country\",\n  \"bbox\",\n  \"limit\",\n  \"proximity\"\n];\nwindow.MapboxAddressAutofill = MapboxAddressAutofill;\nif (!window.customElements.get(\"mapbox-address-autofill\")) {\n  customElements.define(\"mapbox-address-autofill\", MapboxAddressAutofill);\n}\n\n// src/components/MapboxSearchBox.ts\nimport {\n  featureToSuggestion as featureToSuggestion3,\n  LngLatBounds,\n  SearchSession as SearchSession2,\n  SearchBoxCore\n} from \"@mapbox/search-js-core\";\nimport subtag from \"subtag\";\n\n// src/utils/localization.ts\nvar placeholder = {\n  de: \"Suche\",\n  it: \"Ricerca\",\n  en: \"Search\",\n  nl: \"Zoeken\",\n  fr: \"Chercher\",\n  ca: \"Cerca\",\n  he: \"\\u05DC\\u05D7\\u05E4\\u05E9\",\n  ja: \"\\u30B5\\u30FC\\u30C1\",\n  lv: \"Mekl\\u0113t\",\n  pt: \"Procurar\",\n  sr: \"\\u041F\\u0440\\u0435\\u0442\\u0440\\u0430\\u0433\\u0430\",\n  zh: \"\\u641C\\u7D22\",\n  cs: \"Vyhled\\xE1v\\xE1n\\xED\",\n  hu: \"Keres\\xE9s\",\n  ka: \"\\u10EB\\u10D8\\u10D4\\u10D1\\u10D0\",\n  nb: \"S\\xF8ke\",\n  sk: \"Vyh\\u013Ead\\xE1vanie\",\n  th: \"\\u0E04\\u0E49\\u0E19\\u0E2B\\u0E32\",\n  fi: \"Hae\",\n  is: \"Leita\",\n  ko: \"\\uC218\\uC0C9\",\n  pl: \"Szukaj\",\n  sl: \"Iskanje\",\n  fa: \"\\u062C\\u0633\\u062A\\u062C\\u0648\",\n  ru: \"\\u041F\\u043E\\u0438\\u0441\\u043A\"\n};\nvar localization_default = { placeholder };\n\n// src/components/MapboxSearchBox.ts\nvar MAX_ZOOM = 9;\nvar _binding5, _search, _session2, _map, _input2, _listbox2, _getDefaultPlaceholder, getDefaultPlaceholder_fn, _placeholder, _handleSuggest2, _handleSuggestError2, _handleRetrieve2, _mapMarker, _removeMarker, _handleMarker, _onHandleInput2, _onHandleSelect2, _onHandleBlur2, _setActionIcons, _handleClear, _handleMoveEnd;\nvar MapboxSearchBox = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _getDefaultPlaceholder);\n    __privateAdd(this, _binding5, void 0);\n    __privateAdd(this, _search, new SearchBoxCore({}));\n    __privateAdd(this, _session2, new SearchSession2(__privateGet(this, _search)));\n    __privateAdd(this, _map, null);\n    __privateAdd(this, _input2, void 0);\n    __privateAdd(this, _listbox2, new MapboxSearchListbox());\n    this.options = {};\n    __privateAdd(this, _placeholder, void 0);\n    __privateAdd(this, _handleSuggest2, (result) => {\n      __privateGet(this, _setActionIcons).call(this);\n      __privateGet(this, _listbox2).handleSuggest((result == null ? void 0 : result.suggestions) || null);\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggest\", result));\n    });\n    __privateAdd(this, _handleSuggestError2, (error) => {\n      __privateGet(this, _setActionIcons).call(this);\n      __privateGet(this, _listbox2).handleError();\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggesterror\", error));\n    });\n    __privateAdd(this, _handleRetrieve2, (result) => {\n      __privateGet(this, _setActionIcons).call(this);\n      this.dispatchEvent(new MapboxHTMLEvent(\"retrieve\", result));\n      const featureCollection = result;\n      if (!featureCollection || !featureCollection.features.length) {\n        return;\n      }\n      const suggestion = featureToSuggestion3(featureCollection.features[0]);\n      __privateGet(this, _input2).value = suggestion.name;\n      const map = __privateGet(this, _map);\n      if (!map) {\n        return;\n      }\n      const feature = featureCollection.features[0];\n      if (!feature) {\n        return;\n      }\n      const placeType = feature.properties.feature_type;\n      const bounds = feature.properties.bbox;\n      if (bounds) {\n        map.flyTo(bboxViewport(map, LngLatBounds.convert(bounds).toFlatArray()));\n      } else {\n        const center = feature.geometry.coordinates;\n        const zoom = getMaxZoom(placeType);\n        map.flyTo({\n          center,\n          zoom,\n          speed: FLY_TO_SPEED\n        });\n      }\n      if (this.marker && this.mapboxgl) {\n        __privateGet(this, _handleMarker).call(this, feature);\n      }\n    });\n    __privateAdd(this, _mapMarker, void 0);\n    __privateAdd(this, _removeMarker, () => {\n      if (__privateGet(this, _mapMarker)) {\n        __privateGet(this, _mapMarker).remove();\n        __privateSet(this, _mapMarker, null);\n      }\n    });\n    __privateAdd(this, _handleMarker, (feature) => {\n      if (!__privateGet(this, _map)) {\n        return;\n      }\n      __privateGet(this, _removeMarker).call(this);\n      if (!feature)\n        return;\n      const defaultMarkerOptions = {\n        color: \"#4668F2\"\n      };\n      const markerOptions = __spreadValues(__spreadValues({}, defaultMarkerOptions), typeof this.marker === \"object\" && this.marker);\n      __privateSet(this, _mapMarker, new this.mapboxgl.Marker(markerOptions));\n      if (feature.geometry && feature.geometry.type && feature.geometry.type === \"Point\" && feature.geometry.coordinates) {\n        __privateGet(this, _mapMarker).setLngLat(feature.geometry.coordinates).addTo(__privateGet(this, _map));\n      }\n    });\n    this.interceptSearch = null;\n    __privateAdd(this, _onHandleInput2, (e) => {\n      this.dispatchEvent(e.clone());\n      const inputText = e.detail;\n      if (!inputText) {\n        __privateGet(this, _handleClear).call(this);\n        return;\n      }\n      const alteredText = this.interceptSearch && this.interceptSearch(inputText);\n      const searchText = this.interceptSearch ? alteredText : inputText;\n      if (this.interceptSearch && !alteredText) {\n        __privateGet(this, _listbox2).hideResults();\n        return;\n      }\n      __privateGet(this, _session2).suggest(searchText, this.options);\n      __privateGet(this, _setActionIcons).call(this, true);\n    });\n    __privateAdd(this, _onHandleSelect2, (e) => {\n      const suggestion = e.detail;\n      __privateGet(this, _session2).retrieve(suggestion, this.options);\n      __privateGet(this, _setActionIcons).call(this, true);\n    });\n    __privateAdd(this, _onHandleBlur2, () => {\n      __privateGet(this, _session2).abort();\n    });\n    __privateAdd(this, _setActionIcons, (loading = false) => {\n      if (loading) {\n        __privateGet(this, _binding5).ClearBtn.style.display = \"none\";\n        __privateGet(this, _binding5).LoadingIcon.style.display = \"block\";\n      } else {\n        __privateGet(this, _binding5).LoadingIcon.style.display = \"none\";\n        __privateGet(this, _binding5).ClearBtn.style.display = this.value ? \"block\" : \"none\";\n      }\n    });\n    __privateAdd(this, _handleClear, () => {\n      this.value = \"\";\n      __privateGet(this, _setActionIcons).call(this);\n      __privateGet(this, _handleMarker).call(this, null);\n      __privateGet(this, _listbox2).handleSuggest(null);\n    });\n    this.marker = true;\n    __privateAdd(this, _handleMoveEnd, () => {\n      const map = __privateGet(this, _map);\n      const options = __spreadValues({}, this.options);\n      if (map.getZoom() <= MAX_ZOOM) {\n        delete options.proximity;\n        this.options = options;\n        return;\n      }\n      const center = map.getCenter();\n      this.options = __spreadProps(__spreadValues({}, options), {\n        proximity: center\n      });\n    });\n  }\n  get accessToken() {\n    return __privateGet(this, _search).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _search).accessToken = newToken;\n  }\n  get value() {\n    return __privateGet(this, _input2).value;\n  }\n  set value(newValue) {\n    __privateGet(this, _input2).value = newValue;\n  }\n  get input() {\n    return __privateGet(this, _input2);\n  }\n  get template() {\n    return SEARCHBOX_TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".SearchBox\", __privateGet(this, _listbox2).theme);\n  }\n  get theme() {\n    return __privateGet(this, _listbox2).theme;\n  }\n  set theme(theme) {\n    __privateGet(this, _listbox2).theme = theme;\n    if (!__privateGet(this, _binding5) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".SearchBox\", theme));\n    __privateGet(this, _listbox2).updatePopover();\n    const { SearchIcon } = __privateGet(this, _binding5);\n    SearchIcon.innerHTML = getIcon(\"search\", theme);\n  }\n  get popoverOptions() {\n    return __privateGet(this, _listbox2).popoverOptions;\n  }\n  set popoverOptions(newOptions) {\n    __privateGet(this, _listbox2).popoverOptions = newOptions;\n  }\n  get placeholder() {\n    return __privateGet(this, _placeholder) || __privateMethod(this, _getDefaultPlaceholder, getDefaultPlaceholder_fn).call(this);\n  }\n  set placeholder(text) {\n    __privateSet(this, _placeholder, text);\n    if (__privateGet(this, _input2)) {\n      __privateGet(this, _input2).placeholder = this.placeholder;\n      __privateGet(this, _input2).setAttribute(\"aria-label\", this.placeholder);\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding5, bindElements(this, {\n      SearchBox: \".SearchBox\",\n      SearchIcon: \".SearchIcon\",\n      Input: \".Input\",\n      ClearBtn: \".ClearBtn\",\n      LoadingIcon: \".LoadingIcon\"\n    }));\n    this.theme = __spreadValues({}, this.theme);\n    const { Input, ClearBtn } = __privateGet(this, _binding5);\n    __privateSet(this, _input2, Input);\n    __privateGet(this, _listbox2).input = Input;\n    __privateGet(this, _listbox2).searchService = 3 /* SearchBox */;\n    __privateGet(this, _listbox2).addEventListener(\"input\", __privateGet(this, _onHandleInput2));\n    __privateGet(this, _listbox2).addEventListener(\"select\", __privateGet(this, _onHandleSelect2));\n    __privateGet(this, _listbox2).addEventListener(\"blur\", __privateGet(this, _onHandleBlur2));\n    __privateGet(this, _session2).addEventListener(\"suggest\", __privateGet(this, _handleSuggest2));\n    __privateGet(this, _session2).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError2));\n    __privateGet(this, _session2).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve2));\n    ClearBtn.addEventListener(\"click\", __privateGet(this, _handleClear));\n    this.placeholder = __privateGet(this, _placeholder);\n    document.body.appendChild(__privateGet(this, _listbox2));\n    if (Input) {\n      if (Input.previousElementSibling.hasAttribute(\"aria-live\")) {\n        Input.previousElementSibling.remove();\n      }\n      Input.insertAdjacentElement(\"beforebegin\", createAriaLiveElement(__privateGet(this, _listbox2).dataSeed));\n    }\n  }\n  disconnectedCallback() {\n    __privateGet(this, _listbox2).remove();\n    __privateGet(this, _listbox2).input = null;\n    __privateGet(this, _listbox2).removeEventListener(\"input\", __privateGet(this, _onHandleInput2));\n    __privateGet(this, _listbox2).removeEventListener(\"select\", __privateGet(this, _onHandleSelect2));\n    __privateGet(this, _listbox2).removeEventListener(\"blur\", __privateGet(this, _onHandleBlur2));\n    __privateGet(this, _session2).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest2));\n    __privateGet(this, _session2).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError2));\n    __privateGet(this, _session2).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve2));\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      __privateGet(this, _search).accessToken = newValue;\n      return;\n    }\n    if (name === \"theme\") {\n      this.theme = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"popover-options\") {\n      this.popoverOptions = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"placeholder\") {\n      this.placeholder = newValue;\n      return;\n    }\n    const optionName = name.split(\"-\").join(\"_\");\n    if (!newValue) {\n      delete this.options[optionName];\n    }\n    this.options[optionName] = newValue;\n    if (optionName === \"language\") {\n      this.placeholder = __privateGet(this, _placeholder);\n    }\n  }\n  focus() {\n    __privateGet(this, _listbox2).focus();\n  }\n  search(text) {\n    this.value = text;\n    __privateGet(this, _onHandleInput2).call(this, new MapboxHTMLEvent(\"input\", text));\n  }\n  bindMap(map) {\n    if (__privateGet(this, _map)) {\n      __privateGet(this, _map).off(\"moveend\", __privateGet(this, _handleMoveEnd));\n    }\n    if (map) {\n      map.on(\"moveend\", __privateGet(this, _handleMoveEnd));\n    }\n    __privateSet(this, _map, map);\n  }\n  unbindMap() {\n    this.bindMap(null);\n  }\n  onAdd(map) {\n    this.bindMap(map);\n    this.remove();\n    const container = document.createElement(\"div\");\n    container.className = \"mapboxgl-ctrl\";\n    container.style.width = \"300px\";\n    container.appendChild(this);\n    return container;\n  }\n  onRemove() {\n    this.remove();\n    this.unbindMap();\n    __privateGet(this, _removeMarker).call(this);\n  }\n  getDefaultPosition() {\n    return \"top-right\";\n  }\n};\n_binding5 = new WeakMap();\n_search = new WeakMap();\n_session2 = new WeakMap();\n_map = new WeakMap();\n_input2 = new WeakMap();\n_listbox2 = new WeakMap();\n_getDefaultPlaceholder = new WeakSet();\ngetDefaultPlaceholder_fn = function() {\n  if (this.options.language) {\n    const firstLanguage = this.options.language.split(\",\")[0];\n    const language = subtag.language(firstLanguage);\n    const localizedValue = localization_default.placeholder[language];\n    if (localizedValue)\n      return localizedValue;\n  }\n  return \"Search\";\n};\n_placeholder = new WeakMap();\n_handleSuggest2 = new WeakMap();\n_handleSuggestError2 = new WeakMap();\n_handleRetrieve2 = new WeakMap();\n_mapMarker = new WeakMap();\n_removeMarker = new WeakMap();\n_handleMarker = new WeakMap();\n_onHandleInput2 = new WeakMap();\n_onHandleSelect2 = new WeakMap();\n_onHandleBlur2 = new WeakMap();\n_setActionIcons = new WeakMap();\n_handleClear = new WeakMap();\n_handleMoveEnd = new WeakMap();\nMapboxSearchBox.observedAttributes = [\n  \"access-token\",\n  \"theme\",\n  \"popover-options\",\n  \"placeholder\",\n  \"language\",\n  \"country\",\n  \"bbox\",\n  \"limit\",\n  \"navigation-profile\",\n  \"origin\",\n  \"proximity\",\n  \"eta-type\",\n  \"types\"\n];\nwindow.MapboxSearchBox = MapboxSearchBox;\nif (!window.customElements.get(\"mapbox-search-box\")) {\n  customElements.define(\"mapbox-search-box\", MapboxSearchBox);\n}\n\n// src/components/MapboxAddressMinimap.ts\nimport { LngLat } from \"@mapbox/search-js-core\";\n\n// src/utils/minimap.ts\nimport SphericalMercator from \"@mapbox/sphericalmercator\";\nvar merc = new SphericalMercator({ size: 512, antimeridian: true });\nvar MAX_IMAGE_DIM = 1280;\nfunction getAnchorOffset(marker, anchor) {\n  const { width, height } = getElementSize(marker, true);\n  switch (anchor) {\n    case \"center\":\n      return [0, 0];\n    case \"top\":\n      return [0, height / 2];\n    case \"bottom\":\n      return [0, -1 * height / 2];\n    case \"left\":\n      return [width / 2, 0];\n    case \"right\":\n      return [-1 * width / 2, 0];\n    case \"top-left\":\n      return [width / 2, height / 2];\n    case \"top-right\":\n      return [-1 * width / 2, height / 2];\n    case \"bottom-left\":\n      return [width / 2, -1 * height / 2];\n    case \"bottom-right\":\n      return [-1 * width / 2, -1 * height / 2];\n  }\n}\nvar _anchor, _handleAnchorResize, _markerTransform, _isActive, _originalCoordinate, _onPointerDownMarker, _onPointerUpMarker, _onPointerMoveMarker, _onPointerDownImage, _onPointerUpImage, _onPointerMoveImage, _updatePointerPosition, _updateMarkerTransform, _updateMarkerCorrection;\nvar MarkerController = class {\n  constructor(imageContainer, imageElement, marker, keepMarkerCentered, zoom, anchor) {\n    __privateAdd(this, _anchor, void 0);\n    __privateAdd(this, _handleAnchorResize, () => {\n      [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, this.anchor);\n      this.markerTransform = {\n        anchorX: this.anchorOffsetX,\n        anchorY: this.anchorOffsetY\n      };\n    });\n    __privateAdd(this, _markerTransform, {\n      anchorX: 0,\n      anchorY: 0,\n      globalX: 0,\n      globalY: 0,\n      correctionX: 0,\n      correctionY: 0\n    });\n    __privateAdd(this, _isActive, false);\n    __privateAdd(this, _originalCoordinate, void 0);\n    __privateAdd(this, _onPointerDownMarker, (m) => {\n      if (!this.isActive)\n        return;\n      m.preventDefault();\n      m.stopPropagation();\n      __privateGet(this, _updatePointerPosition).call(this, m);\n      window.addEventListener(\"pointermove\", __privateGet(this, _onPointerMoveMarker));\n      window.addEventListener(\"pointerup\", __privateGet(this, _onPointerUpMarker));\n    });\n    __privateAdd(this, _onPointerUpMarker, () => {\n      window.removeEventListener(\"pointermove\", __privateGet(this, _onPointerMoveMarker));\n      window.removeEventListener(\"pointerup\", __privateGet(this, _onPointerUpMarker));\n    });\n    __privateAdd(this, _onPointerMoveMarker, (m) => {\n      m.preventDefault();\n      m.stopPropagation();\n      const diffX = this.curPointerXPos - m.pageX;\n      const diffY = this.curPointerYPos - m.pageY;\n      this.markerDeltaX += diffX;\n      this.markerDeltaY -= diffY;\n      this.markerDeltaX = Math.max(Math.min(this.imgElement.width / 2, this.markerDeltaX), this.imgElement.width / 2 * -1);\n      this.markerDeltaY = Math.max(Math.min(this.imgElement.height / 2, this.markerDeltaY), this.imgElement.height / 2 * -1);\n      const imageOffsetX = this.imgCenterPx[0] - this.imgCenterAdjustedPx[0];\n      const imageOffsetY = this.imgCenterPx[1] - this.imgCenterAdjustedPx[1];\n      const deltaX = this.markerDeltaX - imageOffsetX;\n      const deltaY = this.markerDeltaY + imageOffsetY;\n      this.markerTransform = { globalX: deltaX, globalY: deltaY };\n      __privateGet(this, _updatePointerPosition).call(this, m);\n    });\n    __privateAdd(this, _onPointerDownImage, (m) => {\n      if (!this.isActive)\n        return;\n      m.preventDefault();\n      m.stopPropagation();\n      __privateGet(this, _updatePointerPosition).call(this, m);\n      window.addEventListener(\"pointermove\", __privateGet(this, _onPointerMoveImage));\n      window.addEventListener(\"pointerup\", __privateGet(this, _onPointerUpImage));\n    });\n    __privateAdd(this, _onPointerUpImage, () => {\n      window.removeEventListener(\"pointermove\", __privateGet(this, _onPointerMoveImage));\n      window.removeEventListener(\"pointerup\", __privateGet(this, _onPointerUpImage));\n    });\n    __privateAdd(this, _onPointerMoveImage, (m) => {\n      m.preventDefault();\n      let top = Math.round(this.imgContainerElement.scrollTop + (this.curPointerYPos - m.pageY));\n      top = Math.max(Math.min(this.imgElement.height - this.imgContainerElement.clientHeight, top), 0);\n      let left = Math.round(this.imgContainerElement.scrollLeft + (this.curPointerXPos - m.pageX));\n      left = Math.max(Math.min(this.imgElement.width - this.imgContainerElement.clientWidth, left), 0);\n      this.imgContainerElement.scrollTop = top;\n      this.imgContainerElement.scrollLeft = left;\n      const diffX = Math.round(left - (this.imgElement.width - this.imgContainerElement.clientWidth) / 2);\n      const diffY = Math.round((this.imgElement.height - this.imgContainerElement.clientHeight) / 2 - top);\n      this.imgCenterAdjustedPx = [\n        this.imgCenterPx[0] + diffX,\n        this.imgCenterPx[1] - diffY\n      ];\n      if (!this.keepMarkerCentered) {\n        const deltaX = this.markerDeltaX + diffX;\n        const deltaY = this.markerDeltaY + diffY;\n        this.markerTransform = { globalX: deltaX, globalY: deltaY };\n      }\n      __privateGet(this, _updateMarkerCorrection).call(this, left, top);\n      __privateGet(this, _updatePointerPosition).call(this, m);\n    });\n    __privateAdd(this, _updatePointerPosition, (m) => {\n      this.curPointerXPos = m.pageX;\n      this.curPointerYPos = m.pageY;\n    });\n    __privateAdd(this, _updateMarkerTransform, () => {\n      const { anchorX, anchorY, globalX, globalY, correctionX, correctionY } = __privateGet(this, _markerTransform);\n      const transformX = anchorX - globalX + correctionX;\n      const transformY = anchorY + globalY + correctionY;\n      this.markerElement.style.transform = `translate(calc(-50% + ${transformX}px), calc(-50% + ${transformY}px))`;\n    });\n    this.reCenter = () => {\n      const top = (this.imgElement.height - this.imgContainerElement.clientHeight) / 2;\n      const left = (this.imgElement.width - this.imgContainerElement.clientWidth) / 2;\n      this.imgContainerElement.scrollTop = top;\n      this.imgContainerElement.scrollLeft = left;\n      this.imgCenterAdjustedPx = this.imgCenterPx;\n      this.markerDeltaX = this.markerDeltaY = 0;\n      this.markerTransform = {\n        globalX: 0,\n        globalY: 0,\n        correctionX: 0,\n        correctionY: 0\n      };\n    };\n    this.handleMinimapResize = () => {\n      if (!this.imgElement.height || !this.imgElement.width)\n        return;\n      const centerOffsetX = this.imgCenterOffset.x;\n      const centerOffsetY = this.imgCenterOffset.y;\n      const left = this.imgElement.width / 2 - centerOffsetX - this.imgContainerElement.clientWidth / 2;\n      const top = this.imgElement.height / 2 - centerOffsetY - this.imgContainerElement.clientHeight / 2;\n      this.imgContainerElement.scrollLeft = left;\n      this.imgContainerElement.scrollTop = top;\n      __privateGet(this, _updateMarkerCorrection).call(this, left, top);\n    };\n    __privateAdd(this, _updateMarkerCorrection, (scrollLeft, scrollTop) => {\n      const centerOffsetX = this.imgCenterOffset.x;\n      const centerOffsetY = this.imgCenterOffset.y;\n      const { correctionX, correctionY } = this.markerTransform;\n      const corrections = {};\n      if (scrollLeft / 2 < centerOffsetX * -1) {\n        const markerTranslateX = centerOffsetX * -1 - scrollLeft / 2;\n        corrections.correctionX = markerTranslateX * 2;\n      } else if (scrollLeft < 0) {\n        corrections.correctionX = scrollLeft;\n      } else if (correctionX !== 0) {\n        corrections.correctionX = 0;\n      }\n      if (scrollTop / 2 < centerOffsetY * -1) {\n        const markerTranslateY = centerOffsetY * -1 - scrollTop / 2;\n        corrections.correctionY = markerTranslateY * 2;\n      } else if (scrollTop < 0) {\n        corrections.correctionY = scrollTop;\n      } else if (correctionY !== 0) {\n        corrections.correctionY = 0;\n      }\n      this.markerTransform = corrections;\n    });\n    this.markerElement = marker;\n    this.imgContainerElement = imageContainer;\n    this.imgElement = imageElement;\n    this.keepMarkerCentered = keepMarkerCentered;\n    this.zoom = zoom;\n    this.anchor = anchor;\n    this.curPointerXPos = 0;\n    this.curPointerYPos = 0;\n    this.markerDeltaX = 0;\n    this.markerDeltaY = 0;\n    this.imgContainerElement.addEventListener(\"pointerdown\", __privateGet(this, _onPointerDownImage));\n    if (!this.keepMarkerCentered) {\n      this.markerElement.addEventListener(\"pointerdown\", __privateGet(this, _onPointerDownMarker));\n    }\n    const resizeObserver = new ResizeObserver(__privateGet(this, _handleAnchorResize));\n    resizeObserver.observe(this.markerElement);\n  }\n  get anchor() {\n    return __privateGet(this, _anchor);\n  }\n  set anchor(newAnchor) {\n    __privateSet(this, _anchor, newAnchor);\n    [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, newAnchor);\n    this.markerTransform = {\n      anchorX: this.anchorOffsetX,\n      anchorY: this.anchorOffsetY\n    };\n  }\n  get markerTransform() {\n    return __privateGet(this, _markerTransform);\n  }\n  set markerTransform(val) {\n    __privateSet(this, _markerTransform, __spreadValues(__spreadValues({}, __privateGet(this, _markerTransform)), val));\n    __privateGet(this, _updateMarkerTransform).call(this);\n  }\n  get isActive() {\n    return __privateGet(this, _isActive);\n  }\n  set isActive(val) {\n    this.imgContainerElement.style.touchAction = val ? \"none\" : \"\";\n    __privateSet(this, _isActive, val);\n  }\n  get coordinate() {\n    const adjustedPx = this.keepMarkerCentered ? this.imgCenterAdjustedPx : [\n      this.imgCenterPx[0] - this.markerDeltaX,\n      this.imgCenterPx[1] + this.markerDeltaY\n    ];\n    if (deepEquals(adjustedPx, this.imgCenterPx)) {\n      return __privateGet(this, _originalCoordinate);\n    } else {\n      const lngLat = merc.ll(adjustedPx, this.zoom);\n      return [round(lngLat[0], 6), round(lngLat[1], 6)];\n    }\n  }\n  set coordinate(lngLat) {\n    __privateSet(this, _originalCoordinate, lngLat);\n    this.imgCenterPx = this.imgCenterAdjustedPx = merc.px(lngLat, this.zoom);\n  }\n  get imgCenterOffset() {\n    return {\n      x: this.imgCenterPx[0] - this.imgCenterAdjustedPx[0],\n      y: this.imgCenterPx[1] - this.imgCenterAdjustedPx[1]\n    };\n  }\n};\n_anchor = new WeakMap();\n_handleAnchorResize = new WeakMap();\n_markerTransform = new WeakMap();\n_isActive = new WeakMap();\n_originalCoordinate = new WeakMap();\n_onPointerDownMarker = new WeakMap();\n_onPointerUpMarker = new WeakMap();\n_onPointerMoveMarker = new WeakMap();\n_onPointerDownImage = new WeakMap();\n_onPointerUpImage = new WeakMap();\n_onPointerMoveImage = new WeakMap();\n_updatePointerPosition = new WeakMap();\n_updateMarkerTransform = new WeakMap();\n_updateMarkerCorrection = new WeakMap();\n\n// src/icons/mapboxgl-ctrl-logo.svg\nvar mapboxgl_ctrl_logo_default = '<svg width=\"88\" height=\"23\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill-rule=\"evenodd\"><defs><path id=\"g\" d=\"M11.5 2.25a9.25 9.25 0 1 1 0 18.5 9.25 9.25 0 0 1 0-18.5zM7 15.98c-.05-.33-.83-5.8 2.23-8.87a4.4 4.4 0 0 1 3.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39a4.4 4.4 0 0 1-1.28 3.13C12.72 16.93 7 16 7 16v-.02zm8.3-5.48-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z\"/><path id=\"b\" d=\"M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19A3.77 3.77 0 0 1 50.86 15v3.77c0 .13-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01.01-.01c.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V15a3.7 3.7 0 0 1-2.73 1.19c-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.38-.19a4.24 4.24 0 0 0-4.16 3.29 4.07 4.07 0 0 0 0 1.77 4.23 4.23 0 0 0 4.17 3.3 4.22 4.22 0 0 0 4.26-4.19 4.2 4.2 0 0 0-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18a4 4 0 0 1 3.84 3.28c.13.59.13 1.2 0 1.8a4 4 0 0 1-3.84 3.29A3.77 3.77 0 0 1 60.86 15v.77c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4a.23.23 0 0 1-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55a2.73 2.73 0 0 1 2.44-1.56c1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.62 0h-1.61a.27.27 0 0 1-.12-.03c-.1-.06-.13-.19-.06-.28l2.43-3.71-2.4-3.65a.21.21 0 0 1-.02-.12.2.2 0 0 1 .2-.21h1.61c.13 0 .24.06.3.17L82 10.54l1.4-2.37a.34.34 0 0 1 .3-.17h1.6l.12.03c.1.06.13.19.06.28l-2.37 3.65 2.43 3.7.01.13a.2.2 0 0 1-.2.21h-1.61a.33.33 0 0 1-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 0 1-.3.17zm-7.12-1.49A2.47 2.47 0 0 1 70.7 12a2.47 2.47 0 0 1 2.42-2.52 2.47 2.47 0 0 1 2.42 2.51 2.48 2.48 0 0 1-2.42 2.52zm-19.87 0a2.48 2.48 0 0 1-2.42-2.48v-.07a2.47 2.47 0 0 1 2.4-2.49 2.47 2.47 0 0 1 2.41 2.51 2.47 2.47 0 0 1-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51a2.47 2.47 0 0 1 2.4-2.52 2.46 2.46 0 0 1 2.41 2.48l.02.08zm18.12 2.47a2.47 2.47 0 0 1-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51a2.47 2.47 0 0 1-2.42 2.51z\"/></defs><mask id=\"c\"><rect width=\"100%\" height=\"100%\" fill=\"#fff\"/><use xlink:href=\"#g\"/><use xlink:href=\"#b\"/></mask><g opacity=\".3\" stroke=\"#000\" stroke-width=\"3\"><circle mask=\"url(#c)\" cx=\"11.5\" cy=\"11.5\" r=\"9.25\"/><use xlink:href=\"#b\" mask=\"url(#c)\"/></g><g opacity=\".9\" fill=\"#fff\"><use xlink:href=\"#g\"/><use xlink:href=\"#b\"/></g></svg>';\n\n// src/components/MapboxAddressMinimap.ts\nvar ZOOM = 16;\nvar TEMPLATE4 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressMinimap\" aria-hidden=\"true\">\n    <div class=\"MinimapImageContainer\">\n      <img class=\"MinimapImage\" draggable=\"false\"></img>\n      <div class=\"MinimapInnerFrame\">\n        <div class=\"MinimapMarker\"></div>\n        <div class=\"MinimapAttribution\">\n          <div class=\"MinimapAttributionLogo\">\n            <a target=\"_blank\" rel=\"noopener nofollow\" href=\"https://www.mapbox.com/\" aria-label=\"Mapbox logo\">\n              ${mapboxgl_ctrl_logo_default}\n            </a>\n          </div>\n          <div class=\"MinimapAttributionText\">\n            <a target=\"_blank\" href='https://www.mapbox.com/about/maps/'>\\xA9 Mapbox</a><a target=\"_blank\" href='http://www.openstreetmap.org/copyright'>\\xA9 OpenStreetMap</a>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar STYLE_TOGGLE_TEMPLATE = createElementFromString(`\n<template>\n  <button type=\"button\" class=\"MinimapStyleToggle\"></button>\n</template>\n`);\nvar FOOTER_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MinimapFooter\">Adjust the marker on the map if it doesn't precisely match your location. This helps improve address data quality.</div>\n</template>\n`);\nvar ADJUST_PIN_TEXT = \"Adjust pin\";\nvar SAVE_TEXT = \"Save\";\nvar CANCEL_TEXT = \"Cancel\";\nvar EDIT_BUTTONS_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MinimapEditButtons\">\n    <div class=\"Button ButtonPrimary MinimapButtonAdjust\">${ADJUST_PIN_TEXT}</div>\n    <div class=\"Button ButtonPrimary MinimapButtonSave\" aria-hidden=\"true\">${SAVE_TEXT}</div>\n    <div class=\"Button MinimapButtonCancel\" aria-hidden=\"true\">${CANCEL_TEXT}</div>\n  </div>\n</template>\n`);\nvar _canAdjustMarkerInternal, _isAdjustMarkerEditing, _imageLoaded, _feature2, _url, _width, _height, _binding6, _markerController, _accessToken, _themeInternal5, _satelliteToggleInternal, _mapStyleMode, _adjustBtnText, _saveBtnText, _cancelBtnText, _defaultMapStyle, _footer, _container, _toggleMarkerEditing, _handleStartMarkerEditing, _handleSaveMarkerEditing, _handleCancelMarkerEditing, _handleToggleMapStyle, _handleImageLoad, _handleImageError, _getImageUrl, _updateImageSrc, _getToggleBackgroundImageUrl, _setSize, _addMarkerEditControls, _removeMarkerEditControls, _addSatelliteToggle, _removeSatelliteToggle;\nvar MapboxAddressMinimap = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _canAdjustMarkerInternal, false);\n    this.keepMarkerCentered = false;\n    this.markerAnchor = \"bottom\";\n    __privateAdd(this, _isAdjustMarkerEditing, false);\n    __privateAdd(this, _imageLoaded, false);\n    __privateAdd(this, _feature2, void 0);\n    __privateAdd(this, _url, \"\");\n    __privateAdd(this, _width, void 0);\n    __privateAdd(this, _height, void 0);\n    __privateAdd(this, _binding6, void 0);\n    __privateAdd(this, _markerController, void 0);\n    __privateAdd(this, _accessToken, void 0);\n    __privateAdd(this, _themeInternal5, {});\n    __privateAdd(this, _satelliteToggleInternal, false);\n    __privateAdd(this, _mapStyleMode, \"default\");\n    __privateAdd(this, _adjustBtnText, void 0);\n    __privateAdd(this, _saveBtnText, void 0);\n    __privateAdd(this, _cancelBtnText, void 0);\n    __privateAdd(this, _defaultMapStyle, [\"mapbox\", \"streets-v11\"]);\n    __privateAdd(this, _footer, void 0);\n    __privateAdd(this, _container, void 0);\n    __privateAdd(this, _toggleMarkerEditing, () => {\n      const { ImageContainer, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding6);\n      if (__privateGet(this, _isAdjustMarkerEditing)) {\n        ImageContainer.classList.add(`${this.dataset.seed}--draggable`);\n        __privateGet(this, _markerController).isActive = true;\n        ButtonAdjust.setAttribute(\"aria-hidden\", \"true\");\n        ButtonSave.removeAttribute(\"aria-hidden\");\n        ButtonCancel.removeAttribute(\"aria-hidden\");\n      } else {\n        ImageContainer.classList.remove(`${this.dataset.seed}--draggable`);\n        __privateGet(this, _markerController).isActive = false;\n        ButtonAdjust.removeAttribute(\"aria-hidden\");\n        ButtonSave.setAttribute(\"aria-hidden\", \"true\");\n        ButtonCancel.setAttribute(\"aria-hidden\", \"true\");\n      }\n    });\n    __privateAdd(this, _handleStartMarkerEditing, () => {\n      __privateSet(this, _isAdjustMarkerEditing, true);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleSaveMarkerEditing, () => {\n      if (this.feature.properties.full_address && !deepEquals(this.feature.geometry.coordinates, __privateGet(this, _markerController).coordinate)) {\n        const [lng, lat] = __privateGet(this, _markerController).coordinate;\n        sendFeedback(this.accessToken, {\n          originalCoordinate: this.feature.geometry.coordinates,\n          originalAddress: this.feature.properties.full_address,\n          changes: {\n            location: { longitude: lng, latitude: lat }\n          }\n        });\n      }\n      if (this.onSaveMarkerLocation) {\n        this.onSaveMarkerLocation(__privateGet(this, _markerController).coordinate);\n      }\n      __privateSet(this, _isAdjustMarkerEditing, false);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleCancelMarkerEditing, () => {\n      __privateGet(this, _markerController).reCenter();\n      __privateSet(this, _isAdjustMarkerEditing, false);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleToggleMapStyle, () => {\n      this.mapStyleMode = this.mapStyleMode === \"default\" ? \"satellite\" : \"default\";\n    });\n    __privateAdd(this, _handleImageLoad, () => {\n      if (!__privateGet(this, _imageLoaded)) {\n        __privateGet(this, _markerController).reCenter();\n      }\n      __privateSet(this, _imageLoaded, true);\n      __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();\n    });\n    __privateAdd(this, _handleImageError, () => {\n      __privateSet(this, _imageLoaded, false);\n    });\n    __privateAdd(this, _getImageUrl, (lngLatLike) => {\n      if (__privateGet(this, _width) === 0 || __privateGet(this, _height) === 0)\n        return \"\";\n      const [username, styleId] = this.defaultMapStyle;\n      const defaultBaseUrl = getStaticBaseUrl(username, styleId);\n      const baseUrl = this.mapStyleMode === \"default\" ? defaultBaseUrl : STATIC_BASE_URL_SATELLITE;\n      const skuToken = AUTOFILL_SKU_TOKEN_PREFIX + config.autofillSessionToken.toString();\n      let imgUrl = baseUrl + LngLat.convert(lngLatLike).toArray().join(\",\") + \",\" + ZOOM + \",0/\" + Math.min(__privateGet(this, _width) * 2, MAX_IMAGE_DIM) + \"x\" + Math.min(__privateGet(this, _height) * 2, MAX_IMAGE_DIM) + \"?access_token=\" + this.accessToken + \"&attribution=false&logo=false\";\n      if (config.autofillSessionEnabled) {\n        imgUrl += `&sku=${skuToken}`;\n      }\n      return imgUrl;\n    });\n    __privateAdd(this, _updateImageSrc, () => {\n      if (__privateGet(this, _feature2)) {\n        const lngLat = __privateGet(this, _feature2).geometry.coordinates;\n        __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));\n        const { Image } = __privateGet(this, _binding6);\n        Image.src = __privateGet(this, _url);\n      }\n    });\n    __privateAdd(this, _getToggleBackgroundImageUrl, (styleMode) => {\n      return `url(\"${getImage(styleMode === \"default\" ? \"styleToggleDefault\" : \"styleToggleSatellite\", this.theme)}\")`;\n    });\n    __privateAdd(this, _setSize, () => {\n      const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image } = __privateGet(this, _binding6);\n      const { width, height } = getElementSize(this.container);\n      const [oldWidth, oldHeight] = [__privateGet(this, _width), __privateGet(this, _height)];\n      __privateSet(this, _width, Math.min(width, MAX_IMAGE_DIM));\n      __privateSet(this, _height, Math.min(height, MAX_IMAGE_DIM));\n      MapboxAddressMinimap2.style.setProperty(\"width\", `${__privateGet(this, _width)}px`);\n      MapboxAddressMinimap2.style.setProperty(\"height\", `${__privateGet(this, _height)}px`);\n      ImageContainer.style.setProperty(\"height\", `${__privateGet(this, _height)}px`);\n      ImageContainer.style.setProperty(\"width\", `${__privateGet(this, _width)}px`);\n      const [imgWidth, imgHeight] = [Image.width, Image.height];\n      if (__privateGet(this, _width) > oldWidth && __privateGet(this, _width) > imgWidth / 2 && imgWidth < MAX_IMAGE_DIM || __privateGet(this, _height) > oldHeight && __privateGet(this, _height) > imgHeight / 2 && imgHeight < MAX_IMAGE_DIM) {\n        __privateGet(this, _updateImageSrc).call(this);\n      } else {\n        __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();\n      }\n    });\n    __privateAdd(this, _addMarkerEditControls, () => {\n      const existingFooter = this.querySelector(\".MinimapFooter\");\n      if (existingFooter)\n        return;\n      const footerElement = this.prepareTemplate(FOOTER_TEMPLATE);\n      const minimapElement = this.querySelector(\".MapboxAddressMinimap\");\n      if (!minimapElement)\n        return;\n      minimapElement.appendChild(footerElement);\n      const existingEditBtns = this.querySelector(\".MinimapEditButtons\");\n      if (existingEditBtns)\n        return;\n      const editButtonsElement = this.prepareTemplate(EDIT_BUTTONS_TEMPLATE);\n      const innerFrame = this.querySelector(\".MinimapInnerFrame\");\n      innerFrame.appendChild(editButtonsElement);\n      __privateSet(this, _binding6, __spreadProps(__spreadValues({}, __privateGet(this, _binding6)), {\n        EditButtons: this.querySelector(\".MinimapEditButtons\"),\n        ButtonAdjust: this.querySelector(\".MinimapButtonAdjust\"),\n        ButtonSave: this.querySelector(\".MinimapButtonSave\"),\n        ButtonCancel: this.querySelector(\".MinimapButtonCancel\")\n      }));\n      const { ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding6);\n      ButtonAdjust.addEventListener(\"click\", __privateGet(this, _handleStartMarkerEditing));\n      ButtonSave.addEventListener(\"click\", __privateGet(this, _handleSaveMarkerEditing));\n      ButtonCancel.addEventListener(\"click\", __privateGet(this, _handleCancelMarkerEditing));\n    });\n    __privateAdd(this, _removeMarkerEditControls, () => {\n      if (!__privateGet(this, _binding6))\n        return;\n      const { EditButtons, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding6);\n      const existingFooter = this.querySelector(\".MinimapFooter\");\n      existingFooter == null ? void 0 : existingFooter.remove();\n      EditButtons == null ? void 0 : EditButtons.remove();\n      if (ButtonAdjust) {\n        ButtonAdjust.remove();\n        ButtonAdjust.removeEventListener(\"click\", __privateGet(this, _handleStartMarkerEditing));\n      }\n      if (ButtonSave) {\n        ButtonSave.remove();\n        ButtonSave.removeEventListener(\"click\", __privateGet(this, _handleSaveMarkerEditing));\n      }\n      if (ButtonCancel) {\n        ButtonCancel.remove();\n        ButtonCancel.removeEventListener(\"click\", __privateGet(this, _handleCancelMarkerEditing));\n      }\n      delete __privateGet(this, _binding6).EditButtons;\n      delete __privateGet(this, _binding6).ButtonAdjust;\n      delete __privateGet(this, _binding6).ButtonSave;\n      delete __privateGet(this, _binding6).ButtonCancel;\n    });\n    __privateAdd(this, _addSatelliteToggle, () => {\n      const existingToggle = this.querySelector(\".MinimapStyleToggle\");\n      if (existingToggle)\n        return;\n      const toggleElement = this.prepareTemplate(STYLE_TOGGLE_TEMPLATE);\n      const innerFrame = this.querySelector(\".MinimapInnerFrame\");\n      if (!innerFrame)\n        return;\n      innerFrame.appendChild(toggleElement);\n      __privateGet(this, _binding6).MapStyleToggle = toggleElement;\n      toggleElement.addEventListener(\"click\", __privateGet(this, _handleToggleMapStyle));\n      toggleElement.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === \"default\" ? \"satellite\" : \"default\");\n      toggleElement.setAttribute(\"title\", `Switch to ${this.mapStyleMode === \"default\" ? \"Satellite\" : \"Default\"}`);\n    });\n    __privateAdd(this, _removeSatelliteToggle, () => {\n      if (!__privateGet(this, _binding6))\n        return;\n      const { MapStyleToggle } = __privateGet(this, _binding6);\n      if (!MapStyleToggle)\n        return;\n      MapStyleToggle.remove();\n      MapStyleToggle.removeEventListener(\"click\", __privateGet(this, _handleToggleMapStyle));\n      delete __privateGet(this, _binding6).MapStyleToggle;\n    });\n  }\n  get canAdjustMarker() {\n    return __privateGet(this, _canAdjustMarkerInternal);\n  }\n  set canAdjustMarker(val) {\n    __privateSet(this, _canAdjustMarkerInternal, val);\n    val ? __privateGet(this, _addMarkerEditControls).call(this) : __privateGet(this, _removeMarkerEditControls).call(this);\n  }\n  get accessToken() {\n    return __privateGet(this, _accessToken) || config.accessToken;\n  }\n  set accessToken(newToken) {\n    __privateSet(this, _accessToken, newToken);\n  }\n  get feature() {\n    return __privateGet(this, _feature2);\n  }\n  set feature(feature) {\n    __privateSet(this, _feature2, feature);\n    if (!feature) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  get template() {\n    return TEMPLATE4;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressMinimap\", this.theme);\n  }\n  get satelliteToggle() {\n    return __privateGet(this, _satelliteToggleInternal);\n  }\n  set satelliteToggle(val) {\n    __privateSet(this, _satelliteToggleInternal, val);\n    val ? __privateGet(this, _addSatelliteToggle).call(this) : __privateGet(this, _removeSatelliteToggle).call(this);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal5);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal5, theme);\n    if (!__privateGet(this, _binding6) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressMinimap\", theme));\n    const { Marker, MapStyleToggle } = __privateGet(this, _binding6);\n    Marker.innerHTML = getIcon(\"marker\", theme);\n    if (MapStyleToggle) {\n      MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === \"default\" ? \"satellite\" : \"default\");\n    }\n  }\n  get adjustBtnText() {\n    return __privateGet(this, _adjustBtnText) || ADJUST_PIN_TEXT;\n  }\n  set adjustBtnText(val) {\n    __privateSet(this, _adjustBtnText, val);\n    const adjustBtn = this.querySelector(\".MinimapButtonAdjust\");\n    adjustBtn.textContent = val || ADJUST_PIN_TEXT;\n  }\n  get saveBtnText() {\n    return __privateGet(this, _saveBtnText) || SAVE_TEXT;\n  }\n  set saveBtnText(val) {\n    __privateSet(this, _saveBtnText, val);\n    const saveBtn = this.querySelector(\".MinimapButtonSave\");\n    saveBtn.textContent = val || SAVE_TEXT;\n  }\n  get cancelBtnText() {\n    return __privateGet(this, _cancelBtnText) || CANCEL_TEXT;\n  }\n  set cancelBtnText(val) {\n    __privateSet(this, _cancelBtnText, val);\n    const cancelBtn = this.querySelector(\".MinimapButtonCancel\");\n    cancelBtn.textContent = val || CANCEL_TEXT;\n  }\n  get mapStyleMode() {\n    return __privateGet(this, _mapStyleMode);\n  }\n  set mapStyleMode(styleMode) {\n    const prevStyleMode = __privateGet(this, _mapStyleMode);\n    if (prevStyleMode === styleMode)\n      return;\n    __privateSet(this, _mapStyleMode, styleMode);\n    if (!__privateGet(this, _binding6)) {\n      return;\n    }\n    const { MapStyleToggle } = __privateGet(this, _binding6);\n    if (!MapStyleToggle) {\n      return;\n    }\n    MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, prevStyleMode);\n    MapStyleToggle.setAttribute(\"title\", `Switch to ${prevStyleMode === \"satellite\" ? \"Satellite\" : \"Default\"}`);\n    __privateGet(this, _updateImageSrc).call(this);\n  }\n  get defaultMapStyle() {\n    return __privateGet(this, _defaultMapStyle);\n  }\n  set defaultMapStyle(style) {\n    __privateSet(this, _defaultMapStyle, style);\n    __privateGet(this, _updateImageSrc).call(this);\n  }\n  get footer() {\n    return __privateGet(this, _footer);\n  }\n  set footer(val) {\n    __privateSet(this, _footer, val);\n    const footerEl = this.querySelector(\".MinimapFooter\");\n    if (footerEl) {\n      if (typeof val === \"string\") {\n        footerEl.textContent = val;\n        footerEl.removeAttribute(\"aria-hidden\");\n      } else if (!val) {\n        footerEl.setAttribute(\"aria-hidden\", \"true\");\n      } else {\n        footerEl.removeAttribute(\"aria-hidden\");\n      }\n    }\n  }\n  get container() {\n    return __privateGet(this, _container);\n  }\n  set container(newContainer) {\n    if (newContainer) {\n      newContainer.style.position = \"relative\";\n      __privateSet(this, _container, newContainer);\n    }\n  }\n  show() {\n    if (!__privateGet(this, _feature2)) {\n      return;\n    }\n    const lngLat = __privateGet(this, _feature2).geometry.coordinates;\n    __privateGet(this, _markerController).coordinate = lngLat;\n    __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));\n    const { MapboxAddressMinimap: MapboxAddressMinimap2, Image } = __privateGet(this, _binding6);\n    Image.src = __privateGet(this, _url);\n    MapboxAddressMinimap2.removeAttribute(\"aria-hidden\");\n  }\n  hide() {\n    const { MapboxAddressMinimap: MapboxAddressMinimap2 } = __privateGet(this, _binding6);\n    MapboxAddressMinimap2.setAttribute(\"aria-hidden\", \"true\");\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding6, bindElements(this, {\n      MapboxAddressMinimap: \".MapboxAddressMinimap\",\n      ImageContainer: \".MinimapImageContainer\",\n      Image: \".MinimapImage\",\n      Marker: \".MinimapMarker\",\n      MapStyleToggle: \".MinimapStyleToggle\",\n      EditButtons: \".MinimapEditButtons\",\n      ButtonAdjust: \".MinimapButtonAdjust\",\n      ButtonSave: \".MinimapButtonSave\",\n      ButtonCancel: \".MinimapButtonCancel\"\n    }));\n    this.mapStyleMode = __privateGet(this, _mapStyleMode);\n    this.theme = __spreadValues({}, this.theme);\n    if (this.canAdjustMarker) {\n      __privateGet(this, _addMarkerEditControls).call(this);\n    }\n    if (this.satelliteToggle) {\n      __privateGet(this, _addSatelliteToggle).call(this);\n    }\n    this.container = this.parentElement;\n    const resizeObserver = new ResizeObserver(__privateGet(this, _setSize));\n    resizeObserver.observe(this.container);\n    __privateGet(this, _setSize).call(this);\n    const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image, Marker } = __privateGet(this, _binding6);\n    __privateSet(this, _markerController, new MarkerController(ImageContainer, Image, Marker, this.keepMarkerCentered, ZOOM, this.markerAnchor));\n    __privateGet(this, _markerController).reCenter();\n    Image.onload = __privateGet(this, _handleImageLoad);\n    Image.onerror = __privateGet(this, _handleImageError);\n    Image.src = __privateGet(this, _url);\n    if (__privateGet(this, _feature2))\n      MapboxAddressMinimap2.removeAttribute(\"aria-hidden\");\n    else\n      MapboxAddressMinimap2.setAttribute(\"aria-hidden\", \"true\");\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      this.accessToken = newValue;\n    } else if (name === \"can-adjust-marker\") {\n      this.canAdjustMarker = newValue === \"true\";\n    } else if (name === \"keep-marker-centered\") {\n      this.keepMarkerCentered = newValue === \"true\";\n    } else if (name === \"marker-anchor\") {\n      const newAnchor = newValue;\n      this.markerAnchor = newAnchor;\n      __privateGet(this, _markerController) && (__privateGet(this, _markerController).anchor = newAnchor);\n    } else if (name === \"satellite-toggle\") {\n      this.satelliteToggle = newValue === \"true\";\n    }\n  }\n};\n_canAdjustMarkerInternal = new WeakMap();\n_isAdjustMarkerEditing = new WeakMap();\n_imageLoaded = new WeakMap();\n_feature2 = new WeakMap();\n_url = new WeakMap();\n_width = new WeakMap();\n_height = new WeakMap();\n_binding6 = new WeakMap();\n_markerController = new WeakMap();\n_accessToken = new WeakMap();\n_themeInternal5 = new WeakMap();\n_satelliteToggleInternal = new WeakMap();\n_mapStyleMode = new WeakMap();\n_adjustBtnText = new WeakMap();\n_saveBtnText = new WeakMap();\n_cancelBtnText = new WeakMap();\n_defaultMapStyle = new WeakMap();\n_footer = new WeakMap();\n_container = new WeakMap();\n_toggleMarkerEditing = new WeakMap();\n_handleStartMarkerEditing = new WeakMap();\n_handleSaveMarkerEditing = new WeakMap();\n_handleCancelMarkerEditing = new WeakMap();\n_handleToggleMapStyle = new WeakMap();\n_handleImageLoad = new WeakMap();\n_handleImageError = new WeakMap();\n_getImageUrl = new WeakMap();\n_updateImageSrc = new WeakMap();\n_getToggleBackgroundImageUrl = new WeakMap();\n_setSize = new WeakMap();\n_addMarkerEditControls = new WeakMap();\n_removeMarkerEditControls = new WeakMap();\n_addSatelliteToggle = new WeakMap();\n_removeSatelliteToggle = new WeakMap();\nMapboxAddressMinimap.observedAttributes = [\n  \"access-token\",\n  \"can-adjust-marker\",\n  \"keep-marker-centered\",\n  \"marker-anchor\",\n  \"satellite-toggle\"\n];\nwindow.MapboxAddressMinimap = MapboxAddressMinimap;\nif (!window.customElements.get(\"mapbox-address-minimap\")) {\n  customElements.define(\"mapbox-address-minimap\", MapboxAddressMinimap);\n}\n\n// src/autofill.ts\nimport {\n  Evented,\n  AddressAutofillCore as AddressAutofillCore2,\n  SearchSession as SearchSession3\n} from \"@mapbox/search-js-core\";\nvar _input3, _collection, _session3, _initialAutocompleteValue2, _onHandleInput3, _onHandleSelect3, _onHandleBlur3, _onHandleFocus2, _handleSuggest3, _handleSuggestError3, _handleRetrieve3;\nvar AddressAutofillInstance = class {\n  constructor(collection, input, autofillRef) {\n    __privateAdd(this, _input3, void 0);\n    __privateAdd(this, _collection, void 0);\n    __privateAdd(this, _session3, void 0);\n    this.options = {};\n    this.retrieveFeature = null;\n    this.listbox = new MapboxSearchListbox();\n    __privateAdd(this, _initialAutocompleteValue2, void 0);\n    __privateAdd(this, _onHandleInput3, (e) => {\n      const value = e.detail;\n      const enableBrowserAutocomplete = __privateGet(this, _collection).browserAutofillEnabled === true && (value == null ? void 0 : value.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), enableBrowserAutocomplete);\n      if ((value == null ? void 0 : value.length) <= 2) {\n        this.listbox.handleSuggest(null);\n        return;\n      }\n      __privateGet(this, _session3).suggest(value, this.options);\n    });\n    __privateAdd(this, _onHandleSelect3, (e) => {\n      const suggestion = e.detail;\n      if (e.detail.accuracy !== \"street\") {\n        toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), true);\n        __privateGet(this, _session3).retrieve(suggestion, this.options);\n      } else {\n        handleStreetSelection(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), suggestion);\n      }\n    });\n    __privateAdd(this, _onHandleBlur3, () => {\n      toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), true);\n      __privateGet(this, _session3).abort();\n    });\n    __privateAdd(this, _onHandleFocus2, () => {\n      var _a;\n      const enableBrowserAutocomplete = __privateGet(this, _collection).browserAutofillEnabled === true && ((_a = __privateGet(this, _input3).value) == null ? void 0 : _a.length) <= 2;\n      toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), enableBrowserAutocomplete);\n    });\n    __privateAdd(this, _handleSuggest3, (result) => {\n      const filteredSuggestions = (result == null ? void 0 : result.suggestions) ? distinctExactStreetResults(result.suggestions) : null;\n      this.listbox.handleSuggest(filteredSuggestions);\n      const event = new MapboxHTMLEvent(\"suggest\", result);\n      Object.defineProperty(event, \"target\", { value: __privateGet(this, _input3) });\n      __privateGet(this, _collection).fire(\"suggest\", event);\n    });\n    __privateAdd(this, _handleSuggestError3, (error) => {\n      this.listbox.handleError();\n      const event = new MapboxHTMLEvent(\"suggesterror\", error);\n      Object.defineProperty(event, \"target\", { value: __privateGet(this, _input3) });\n      __privateGet(this, _collection).fire(\"suggesterror\", event);\n    });\n    __privateAdd(this, _handleRetrieve3, (result) => {\n      var _a;\n      const event = new MapboxHTMLEvent(\"retrieve\", result);\n      Object.defineProperty(event, \"target\", { value: __privateGet(this, _input3) });\n      __privateGet(this, _collection).fire(\"retrieve\", event);\n      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];\n      if (!__privateGet(this, _input3)) {\n        return;\n      }\n      const featureCollection = result;\n      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {\n        return;\n      }\n      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input3));\n    });\n    __privateSet(this, _input3, input);\n    __privateSet(this, _collection, collection);\n    __privateSet(this, _session3, new SearchSession3(autofillRef));\n    __privateGet(this, _session3).sessionToken = config.autofillSessionToken;\n    this.listbox.input = __privateGet(this, _input3);\n    this.listbox.autofillHost = this;\n    this.listbox.searchService = 0 /* AddressAutofill */;\n    this.listbox.addEventListener(\"input\", __privateGet(this, _onHandleInput3));\n    this.listbox.addEventListener(\"select\", __privateGet(this, _onHandleSelect3));\n    this.listbox.addEventListener(\"blur\", __privateGet(this, _onHandleBlur3));\n    this.listbox.addEventListener(\"focus\", __privateGet(this, _onHandleFocus2));\n    __privateGet(this, _session3).addEventListener(\"suggest\", __privateGet(this, _handleSuggest3));\n    __privateGet(this, _session3).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError3));\n    __privateGet(this, _session3).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve3));\n    document.body.appendChild(this.listbox);\n    if (input) {\n      input.insertAdjacentElement(\"beforebegin\", createAriaLiveElement(this.listbox.dataSeed));\n      suppressExtensionsAutocomplete(input);\n      __privateSet(this, _initialAutocompleteValue2, input.autocomplete);\n    }\n  }\n  get input() {\n    return __privateGet(this, _input3);\n  }\n  remove() {\n    this.listbox.remove();\n    this.listbox.removeEventListener(\"input\", __privateGet(this, _onHandleInput3));\n    this.listbox.removeEventListener(\"select\", __privateGet(this, _onHandleSelect3));\n    this.listbox.removeEventListener(\"blur\", __privateGet(this, _onHandleBlur3));\n    this.listbox.removeEventListener(\"focus\", __privateGet(this, _onHandleFocus2));\n    __privateGet(this, _session3).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest3));\n    __privateGet(this, _session3).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError3));\n    __privateGet(this, _session3).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve3));\n  }\n  simulateRetrieve(feature) {\n    const input = __privateGet(this, _input3);\n    if (input) {\n      input.dataset[\"mapboxSuccess\"] = \"true\";\n    }\n    this.listbox.hideResults();\n    const simResult = {\n      type: \"FeatureCollection\",\n      features: [feature],\n      url: \"\"\n    };\n    __privateGet(this, _handleRetrieve3).call(this, simResult);\n  }\n};\n_input3 = new WeakMap();\n_collection = new WeakMap();\n_session3 = new WeakMap();\n_initialAutocompleteValue2 = new WeakMap();\n_onHandleInput3 = new WeakMap();\n_onHandleSelect3 = new WeakMap();\n_onHandleBlur3 = new WeakMap();\n_onHandleFocus2 = new WeakMap();\n_handleSuggest3 = new WeakMap();\n_handleSuggestError3 = new WeakMap();\n_handleRetrieve3 = new WeakMap();\nvar _currentInputs, _autofill2, _options2, _theme, _popoverOptions2, _handleObserve2, _observer2, _handleBrowserAutofill2;\nvar AddressAutofillCollection = class extends Evented {\n  constructor({\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    confirmOnBrowserAutofill,\n    browserAutofillEnabled\n  }) {\n    super();\n    this.instances = [];\n    __privateAdd(this, _currentInputs, void 0);\n    __privateAdd(this, _autofill2, new AddressAutofillCore2());\n    __privateAdd(this, _options2, void 0);\n    __privateAdd(this, _theme, void 0);\n    __privateAdd(this, _popoverOptions2, void 0);\n    this.confirmOnBrowserAutofill = false;\n    this.browserAutofillEnabled = false;\n    __privateAdd(this, _handleObserve2, () => {\n      if (!deepEquals(findAddressInputs(), __privateGet(this, _currentInputs))) {\n        this.update();\n      }\n    });\n    __privateAdd(this, _observer2, new MutationObserver(__privateGet(this, _handleObserve2)));\n    __privateAdd(this, _handleBrowserAutofill2, (e) => __async(this, null, function* () {\n      this.instances.forEach((instance) => instance.listbox.blur());\n      for (const instance of this.instances) {\n        const input = instance.listbox.input;\n        yield tryConfirmBrowserAutofill(input, e, this.confirmOnBrowserAutofill, this.accessToken);\n      }\n    }));\n    initDetectBrowserAutofill();\n    window.addEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill2));\n    config.autofillSessionEnabled = true;\n    this.accessToken = accessToken || config.accessToken;\n    options && (this.options = options);\n    theme && (this.theme = theme);\n    popoverOptions && (this.popoverOptions = popoverOptions);\n    confirmOnBrowserAutofill && (this.confirmOnBrowserAutofill = confirmOnBrowserAutofill);\n    browserAutofillEnabled && (this.browserAutofillEnabled = browserAutofillEnabled);\n    this.update();\n  }\n  get accessToken() {\n    return __privateGet(this, _autofill2).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _autofill2).accessToken = newToken;\n  }\n  get options() {\n    return __privateGet(this, _options2);\n  }\n  set options(newOptions) {\n    __privateSet(this, _options2, __spreadValues(__spreadValues({}, __privateGet(this, _options2)), newOptions));\n    this.instances.forEach((instance) => {\n      instance.options = __spreadValues(__spreadValues({}, instance.options), newOptions);\n    });\n  }\n  get theme() {\n    return __privateGet(this, _theme);\n  }\n  set theme(newTheme) {\n    __privateSet(this, _theme, newTheme);\n    this.instances.forEach((instance) => {\n      instance.listbox.theme = newTheme;\n    });\n  }\n  get popoverOptions() {\n    return __privateGet(this, _popoverOptions2);\n  }\n  set popoverOptions(newOptions) {\n    __privateSet(this, _popoverOptions2, newOptions);\n    this.instances.forEach((instance) => {\n      instance.listbox.popoverOptions = newOptions;\n    });\n  }\n  update() {\n    this.instances.forEach((instance) => {\n      instance.remove();\n    });\n    __privateSet(this, _currentInputs, findAddressInputs());\n    this.instances = [];\n    __privateGet(this, _currentInputs).forEach((input) => {\n      const autofillInstance = new AddressAutofillInstance(this, input, __privateGet(this, _autofill2));\n      autofillInstance.options = this.options;\n      autofillInstance.listbox.theme = this.theme;\n      autofillInstance.listbox.popoverOptions = this.popoverOptions;\n      this.instances.push(autofillInstance);\n    });\n  }\n  observe() {\n    __privateGet(this, _observer2).observe(document, {\n      subtree: true,\n      childList: true\n    });\n    __privateGet(this, _handleObserve2).call(this);\n  }\n  unobserve() {\n    __privateGet(this, _observer2).disconnect();\n  }\n  remove() {\n    this.instances.forEach((instance) => {\n      instance.remove();\n    });\n    this.unobserve();\n    window.removeEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill2));\n  }\n};\n_currentInputs = new WeakMap();\n_autofill2 = new WeakMap();\n_options2 = new WeakMap();\n_theme = new WeakMap();\n_popoverOptions2 = new WeakMap();\n_handleObserve2 = new WeakMap();\n_observer2 = new WeakMap();\n_handleBrowserAutofill2 = new WeakMap();\nfunction autofill(optionsArg) {\n  return new AddressAutofillCollection(optionsArg);\n}\nexport {\n  MapboxAddressAutofill,\n  MapboxAddressConfirmation,\n  MapboxAddressMinimap,\n  MapboxHTMLEvent,\n  MapboxSearchBox,\n  autofill,\n  config,\n  confirmAddress,\n  getAutofillSearchText,\n  getFormAutofillValues\n};\n//# sourceMappingURL=index-esm.js.map\n","var SphericalMercator = (function(){\n\n// Closures including constants and other precalculated values.\nvar cache = {},\n    EPSLN = 1.0e-10,\n    D2R = Math.PI / 180,\n    R2D = 180 / Math.PI,\n    // 900913 properties.\n    A = 6378137.0,\n    MAXEXTENT = 20037508.342789244;\n\nfunction isFloat(n){\n    return Number(n) === n && n % 1 !== 0;\n}\n\n// SphericalMercator constructor: precaches calculations\n// for fast tile lookups.\nfunction SphericalMercator(options) {\n    options = options || {};\n    this.size = options.size || 256;\n    this.expansion = (options.antimeridian === true) ? 2 : 1;\n    if (!cache[this.size]) {\n        var size = this.size;\n        var c = cache[this.size] = {};\n        c.Bc = [];\n        c.Cc = [];\n        c.zc = [];\n        c.Ac = [];\n        for (var d = 0; d < 30; d++) {\n            c.Bc.push(size / 360);\n            c.Cc.push(size / (2 * Math.PI));\n            c.zc.push(size / 2);\n            c.Ac.push(size);\n            size *= 2;\n        }\n    }\n    this.Bc = cache[this.size].Bc;\n    this.Cc = cache[this.size].Cc;\n    this.zc = cache[this.size].zc;\n    this.Ac = cache[this.size].Ac;\n};\n\n// Convert lon lat to screen pixel value\n//\n// - `ll` {Array} `[lon, lat]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.px = function(ll, zoom) {\n  if (isFloat(zoom)) {\n    var size = this.size * Math.pow(2, zoom);\n    var d = size / 2;\n    var bc = (size / 360);\n    var cc = (size / (2 * Math.PI));\n    var ac = size;\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = d + ll[0] * bc;\n    var y = d + 0.5 * Math.log((1 + f) / (1 - f)) * -cc;\n    (x > ac * this.expansion) && (x = ac * this.expansion);\n    (y > ac) && (y = ac);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n  } else {\n    var d = this.zc[zoom];\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = Math.round(d + ll[0] * this.Bc[zoom]);\n    var y = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * (-this.Cc[zoom]));\n    (x > this.Ac[zoom] * this.expansion) && (x = this.Ac[zoom] * this.expansion);\n    (y > this.Ac[zoom]) && (y = this.Ac[zoom]);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n  }\n};\n\n// Convert screen pixel value to lon lat\n//\n// - `px` {Array} `[x, y]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.ll = function(px, zoom) {\n  if (isFloat(zoom)) {\n    var size = this.size * Math.pow(2, zoom);\n    var bc = (size / 360);\n    var cc = (size / (2 * Math.PI));\n    var zc = size / 2;\n    var g = (px[1] - zc) / -cc;\n    var lon = (px[0] - zc) / bc;\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n  } else {\n    var g = (px[1] - this.zc[zoom]) / (-this.Cc[zoom]);\n    var lon = (px[0] - this.zc[zoom]) / this.Bc[zoom];\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n  }\n};\n\n// Convert tile xyz value to bbox of the form `[w, s, e, n]`\n//\n// - `x` {Number} x (longitude) number.\n// - `y` {Number} y (latitude) number.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection for resulting bbox (WGS84|900913).\n// - `return` {Array} bbox array of values in form `[w, s, e, n]`.\nSphericalMercator.prototype.bbox = function(x, y, zoom, tms_style, srs) {\n    // Convert xyz into bbox with srs WGS84\n    if (tms_style) {\n        y = (Math.pow(2, zoom) - 1) - y;\n    }\n    // Use +y to make sure it's a number to avoid inadvertent concatenation.\n    var ll = [x * this.size, (+y + 1) * this.size]; // lower left\n    // Use +x to make sure it's a number to avoid inadvertent concatenation.\n    var ur = [(+x + 1) * this.size, y * this.size]; // upper right\n    var bbox = this.ll(ll, zoom).concat(this.ll(ur, zoom));\n\n    // If web mercator requested reproject to 900913.\n    if (srs === '900913') {\n        return this.convert(bbox, '900913');\n    } else {\n        return bbox;\n    }\n};\n\n// Convert bbox to xyx bounds\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection of input bbox (WGS84|900913).\n// - `@return` {Object} XYZ bounds containing minX, maxX, minY, maxY properties.\nSphericalMercator.prototype.xyz = function(bbox, zoom, tms_style, srs) {\n    // If web mercator provided reproject to WGS84.\n    if (srs === '900913') {\n        bbox = this.convert(bbox, 'WGS84');\n    }\n\n    var ll = [bbox[0], bbox[1]]; // lower left\n    var ur = [bbox[2], bbox[3]]; // upper right\n    var px_ll = this.px(ll, zoom);\n    var px_ur = this.px(ur, zoom);\n    // Y = 0 for XYZ is the top hence minY uses px_ur[1].\n    var x = [ Math.floor(px_ll[0] / this.size), Math.floor((px_ur[0] - 1) / this.size) ];\n    var y = [ Math.floor(px_ur[1] / this.size), Math.floor((px_ll[1] - 1) / this.size) ];\n    var bounds = {\n        minX: Math.min.apply(Math, x) < 0 ? 0 : Math.min.apply(Math, x),\n        minY: Math.min.apply(Math, y) < 0 ? 0 : Math.min.apply(Math, y),\n        maxX: Math.max.apply(Math, x),\n        maxY: Math.max.apply(Math, y)\n    };\n    if (tms_style) {\n        var tms = {\n            minY: (Math.pow(2, zoom) - 1) - bounds.maxY,\n            maxY: (Math.pow(2, zoom) - 1) - bounds.minY\n        };\n        bounds.minY = tms.minY;\n        bounds.maxY = tms.maxY;\n    }\n    return bounds;\n};\n\n// Convert projection of given bbox.\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `to` {String} projection of output bbox (WGS84|900913). Input bbox\n//   assumed to be the \"other\" projection.\n// - `@return` {Object} bbox with reprojected coordinates.\nSphericalMercator.prototype.convert = function(bbox, to) {\n    if (to === '900913') {\n        return this.forward(bbox.slice(0, 2)).concat(this.forward(bbox.slice(2,4)));\n    } else {\n        return this.inverse(bbox.slice(0, 2)).concat(this.inverse(bbox.slice(2,4)));\n    }\n};\n\n// Convert lon/lat values to 900913 x/y.\nSphericalMercator.prototype.forward = function(ll) {\n    var xy = [\n        A * ll[0] * D2R,\n        A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * ll[1] * D2R)))\n    ];\n    // if xy value is beyond maxextent (e.g. poles), return maxextent.\n    (xy[0] > MAXEXTENT) && (xy[0] = MAXEXTENT);\n    (xy[0] < -MAXEXTENT) && (xy[0] = -MAXEXTENT);\n    (xy[1] > MAXEXTENT) && (xy[1] = MAXEXTENT);\n    (xy[1] < -MAXEXTENT) && (xy[1] = -MAXEXTENT);\n    return xy;\n};\n\n// Convert 900913 x/y values to lon/lat.\nSphericalMercator.prototype.inverse = function(xy) {\n    return [\n        (xy[0] * R2D / A),\n        ((Math.PI*0.5) - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D\n    ];\n};\n\nreturn SphericalMercator;\n\n})();\n\nif (typeof module !== 'undefined' && typeof exports !== 'undefined') {\n    module.exports = exports = SphericalMercator;\n}\n","/*!\n* focus-trap 6.9.4\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, isFocusable } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n\n\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n          tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      optionValue = optionValue.apply(void 0, params);\n    }\n\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all\n\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return isTabbable(n, config.tabbableOptions);\n            });\n          }\n\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return isTabbable(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    var target = getActualTarget(e);\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n\n    get paused() {\n      return state.paused;\n    },\n\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","(function(root) {\n  var isOn = false;\n  var scrollbarSize;\n  var scrollTop;\n\n  function getScrollbarSize() {\n    if (typeof scrollbarSize !== 'undefined') return scrollbarSize;\n\n    var doc = document.documentElement;\n    var dummyScroller = document.createElement('div');\n    dummyScroller.setAttribute('style', 'width:99px;height:99px;' + 'position:absolute;top:-9999px;overflow:scroll;');\n    doc.appendChild(dummyScroller);\n    scrollbarSize = dummyScroller.offsetWidth - dummyScroller.clientWidth;\n    doc.removeChild(dummyScroller);\n    return scrollbarSize;\n  }\n\n  function hasScrollbar() {\n    return document.documentElement.scrollHeight > window.innerHeight;\n  }\n\n  function on(options) {\n    if (typeof document === 'undefined' || isOn) return;\n    var doc = document.documentElement;\n    scrollTop = window.pageYOffset;\n    if (hasScrollbar()) {\n      doc.style.width = 'calc(100% - '+ getScrollbarSize() +'px)';\n    } else {\n      doc.style.width = '100%';\n    }\n    doc.style.position = 'fixed';\n    doc.style.top = -scrollTop + 'px';\n    doc.style.overflow = 'hidden';\n    isOn = true;\n  }\n\n  function off() {\n    if (typeof document === 'undefined' || !isOn) return;\n    var doc = document.documentElement;\n    doc.style.width = '';\n    doc.style.position = '';\n    doc.style.top = '';\n    doc.style.overflow = '';\n    window.scroll(0, scrollTop);\n    isOn = false;\n  }\n\n  function toggle() {\n    if (isOn) {\n      off();\n      return;\n    }\n    on();\n  }\n\n  var noScroll = {\n    on: on,\n    off: off,\n    toggle: toggle,\n  };\n\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = noScroll;\n  } else {\n    root.noScroll = noScroll;\n  }\n})(this);\n","!function(root, name, make) {\r\n  if (typeof module != 'undefined' && module.exports) module.exports = make()\r\n  else root[name] = make()\r\n}(this, 'subtag', function() {\r\n\r\n  var empty = ''\r\n  var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/\r\n\r\n  function match(tag) {\r\n    return tag.match(pattern) || []\r\n  }\r\n\r\n  function split(tag) {\r\n    return match(tag).filter(function(v, i) { return v && i })\r\n  }\r\n\r\n  function api(tag) {\r\n    tag = match(tag)\r\n    return {\r\n      language: tag[1] || empty,\r\n      extlang: tag[2] || empty,\r\n      script: tag[3] || empty,\r\n      region: tag[4] || empty\r\n    }\r\n  }\r\n\r\n  function expose(target, key, value) {\r\n    Object.defineProperty(target, key, {\r\n      value: value,\r\n      enumerable: true\r\n    })\r\n  }\r\n\r\n  function part(position, pattern, type) {\r\n    function method(tag) {\r\n      return match(tag)[position] || empty\r\n    }\r\n    expose(method, 'pattern', pattern)\r\n    expose(api, type, method)\r\n  }\r\n\r\n  part(1, /^[a-zA-Z]{2,3}$/, 'language')\r\n  part(2, /^[a-zA-Z]{3}$/, 'extlang')\r\n  part(3, /^[a-zA-Z]{4}$/, 'script')\r\n  part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, 'region')\r\n\r\n  expose(api, 'split', split)\r\n\r\n  return api\r\n});\r\n","/*!\n* tabbable 5.3.3\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\n\n\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      } // iterate over shadow content if possible\n\n\n      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n\n  return candidates;\n};\n\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || getRootNode(node);\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n\n  return width === 0 && height === 0;\n};\n\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n\n\n  var nodeRootHost = getRootNode(node).host;\n  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n\n    if (nodeIsAttached) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    } // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  } // visible, as far as we can tell, or per current `displayCheck` mode\n\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i); // when the first <legend> (in document order) is found\n\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        } // the disabled <fieldset> containing `node` has no <legend>\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  } // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n\n\n  return false;\n};\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\n\n\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scope;\n    var element = isScope ? item.scope : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n\n  return sortByOrder(candidates);\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      const prevDimensions = await platform.getDimensions(elements.floating);\n      apply == null ? void 0 : apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  //  Always-visible scrollbar or not\n  //  Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {MapboxSearchBox} from \"@mapbox/search-js-web\";\n\ndocument.onreadystatechange = () => {\n    if (document.readyState === \"interactive\") {\n\n        const addrField = document.getElementById('Address');\n        const countryField = document.getElementById('Country');\n        const cityField = document.getElementById('City');\n        const latField = document.getElementById('Latitude');\n        const lonField = document.getElementById('Longitude');\n\n        const search = document.querySelectorAll('mapbox-address-autofill')[0];\n        if (document.OSMConfig) {\n            search.options = document.OSMConfig;\n        }\n\n        search.options.\n\n        search.addEventListener('retrieve', (event) => {\n            let properties = event.detail.features[0].properties;\n            let geometry = event.detail.features[0].geometry;\n            console.log(geometry);\n            addrField.value = properties.full_address\n            countryField.value = properties.country;\n            cityField.value = properties.place_name;\n            latField.value = geometry.coordinates[1];\n            lonField.value = geometry.coordinates[0];\n        });\n    }\n}\n\n"],"names":["MapboxSearchBox","document","onreadystatechange","readyState","addrField","getElementById","countryField","cityField","latField","lonField","search","querySelectorAll","OSMConfig","options","addEventListener","event","properties","detail","features","geometry","console","log","value","full_address","country","place_name","coordinates"],"sourceRoot":""}